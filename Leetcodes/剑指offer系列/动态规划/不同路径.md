## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

**示例 1:**

```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

**示例 2:**

```
输入: m = 7, n = 3
输出: 28
```

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 10 ^ 9`

### 动态规划

**状态表示**：$f[i][j] $表示所有从起点走到$[i,j]$的路径

**状态表示的属性**：路径的数量。

**初始化**：第一行第一列都在边界上，路径为1，因此`f[0][j]`和`f[i][0]`都为1。

**集合的划分**【转移方程】: 

- 最后一步向下走：$down = f[i-1][j]$
- 最后一步向右走：$right = f[i][j -1]$
- 结果：$f[i][j] = down + right$

**返回结果**：$res = f[i-1][j-1]$

- $$f[i][j] = \begin{cases} 1,& \mbox{i = 0 or j = 0} \\ dp[i - 1][j] + dp[i][j - 1], & \mbox{others} \end{cases}$$

```java
    public int uniquePaths(int m, int n) {
        //f[m,n]表示走到m,n的路径 res = f[m-1][n-1]
        int[][] f = new int[m][n];

        for(int i = 0; i < m; i ++){
            for(int j = 0; j < n; j++){
                if(i == 0 || j == 0) f[i][j] = 1;
                else f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
```

## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

说明：m 和n的值均不超过 100。

**示例 1:**

```
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

### 动态规划

**状态表示**：$f[i][j] $表示所有从起点走到$[i,j]$的路径

**状态表示的属性**：路径的数量。

**初始化**：第一行，第一列的路径数。

**集合的划分**【转移方程】: 

- 最后一步向下走：$down = f[i-1][j]$
- 最后一步向右走：$right = f[i][j -1]$
- 结果：$f[i][j] = down + right$

**返回结果**：$res = f[i-1][j-1]$

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] g) {
        if (g == null || g.length == 0) {
            return 0;
        } 
        // 定义 dp 数组并初始化第 1 行和第 1 列。
        int m = g.length, n = g[0].length;
        int[][] f = new int[m][n];
        
        for(int i = 0; i < m && g[i][0] != 1; i++){ //为第一行的路径赋值，直到遇到障碍物
            f[i][0] = 1;
        }

        for(int i = 0; i < n && g[0][i] != 1; i++){//为第一列的路径赋值，直到遇到障碍物
            f[0][i] = 1;
        }
        for(int i = 1; i < m; i ++){
            for(int j = 1; j < n; j++){
                
                if(g[i][j] == 1) continue; //如果遇到障碍物，跳过，默认为0
                else{
                    f[i][j] = f[i - 1][j] + f[i][j - 1];//等于上面来的+左面来的
                }
            }
        }
        return f[m - 1][n - 1];
    }
}
```

另一种做法：

```java
    public int uniquePathsWithObstacles(int[][] g) {
        if (g == null || g.length == 0) {
            return 0;
        } 
        // 定义 dp 数组并初始化第 1 行和第 1 列。
        int m = g.length, n = g[0].length;
        int[][] f = new int[m][n];
        for(int i = 0; i < m; i ++){
            for(int j = 0; j < n; j++){
                if(g[i][j] == 1) continue; //遇到障碍物 跳过
                if( i == 0 && j == 0 ) f[i][j] = 1; //左上角顶点处，初始化为1
                if( i > 0 ) f[i][j] += f[i - 1][j];
                if( j > 0 ) f[i][j] += f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
```

