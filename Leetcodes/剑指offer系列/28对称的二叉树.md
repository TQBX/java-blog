#### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

> 文中图片来源：[https://krahets.gitee.io/](https://krahets.gitee.io/)

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

**示例 1：**

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

**限制：**

```
0 <= 节点个数 <= 1000
```

**思考：**

何谓对称？![](img\3.png)

**一、递归方式**

这道题的关键点在于**对称的定义**，对于树中任意两个对称的节点L和R，一定有：

- L.val == R.val
- L.left.val == R.right.val
- L.right.val == R.left.val

**既然是递归，我们就需要考虑以下几个关键部分：**

1. **递归的终止条件**：
   1. 这里是`root == null`，说明此时自上而下的节点都对称，返回true。
   2. （我们需要明确只要有不对称的条件存在，就会直接返回false。
      - L和R其中一个已经到头，表示非对称，返回false。
      - L和R的值不相等，返回false。
2. **如何递推**：分别获取左右子树的root节点，即`helper(root.left)`，`helper(root.right)`
3. **返回值如何**：两对节点都对称的时候，才为true。

```java
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true; //对root进行特判
        return helper(root.left, root.right);
    }

    boolean helper(TreeNode left,TreeNode right){
        if(left == null && right == null) return true;
        if(left == null || right == null || left.val != right.val) return false;
        return helper(left.left,right.right) && helper(right.left,left.right);
    }
```

**时间复杂度**：o(n)每一次helper都可以确定一对节点，最多确定n/2次。

**空间复杂度**：o(n)，最差的时候，退化为链表。