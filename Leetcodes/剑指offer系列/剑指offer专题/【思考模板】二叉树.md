#### 【题目描述】

文中图片来源：[https://krahets.gitee.io/](https://krahets.gitee.io/)

---

#### 【思考】

**一、递归方式**

这道题的关键点在于**镜像的定义**，如果两个树A,B互为镜像，那么`A.left == B.right,A.right == B.left`，那么我们就可以采取递归的方法，交换左右两个子节点。

**既然是递归，我们就需要考虑以下几个关键部分：**

1. **递归的终止条件**：这里是`root == null`，说明此时已经到了叶子节点的下一层，返回null。
2. **如何递推**：
   1. 分别获取左右子树的root节点，即`mirrorTree(root.left)`，`mirrorTree(root.right)`。
   2. 交换两者即可。
3. **返回值如何**：返回值也就是每一层递归退出的时候，向上传递什么值，这个很关键，这里就是返回交换后得到的root。

```java
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return null;
        TreeNode left = mirrorTree(root.left);
        TreeNode right = mirrorTree(root.right);

        root.left = right;
        root.right = left;
        return root;
    }
```

时间复杂度：o(n)，n为节点的数量。

空间复杂度：o(n)，树退化为链表，递归深度为n。

**二、层序遍历**

```java
    public TreeNode mirrorTree(TreeNode root) {
		if (root == null) return null;
		Queue<TreeNode> queue = new LinkedList<>();
		// 根节点入队
		queue.offer(root);
		while (!queue.isEmpty()) {
			int n = queue.size(); // 每一层的节点个数
			for (int i = 0; i < n; i++) {
				TreeNode node = queue.poll();//每次从队列中取出，并交换左右子节点
                TreeNode left = node.left;
                TreeNode right = node.right;
                node.left = right;
                node.right = left;
				if (node.left != null)
					queue.offer(node.left);
				if (node.right != null)
					queue.offer(node.right);
			}
		}
		return root;
	}
```

时间复杂度：o(n)，n为节点数量。

空间复杂度：最差情况下，队列需要同时存储n/2个节点。

