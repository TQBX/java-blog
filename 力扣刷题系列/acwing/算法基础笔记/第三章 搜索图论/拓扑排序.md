```
* 拓扑排序的算法思路
* 1. 计算每个节点的入度
* 2. 一开始入度为0的点可以先移除，入队
* 3. 循环，每次从队头出队，数量--，将出队点的邻接点入度减1，如果入度减1后为0，入队
* 4. 如果最后队列为空，判断节点数量是否为0，不为0表示有环
```

```java
public class JavaTopSort {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 入嘟
        int[] d = new int[numCourses];
        // 建图
        List<Integer>[] g = new ArrayList[numCourses];
        Arrays.setAll(g, e -> new ArrayList<>());
        // 计算每个节点的入度
        for(int[] p : prerequisites) {
            g[p[1]].add(p[0]);
            d[p[0]]++;
        }
        // 一开始入度为0的点可以先移除，入队
        Queue<Integer> q = new LinkedList<>();
        for(int i = 0; i < numCourses; i++) {
            if(d[i] == 0) {
                q.offer(i);
            }
        }

        // 循环，每次从队头出队，数量--，将出队点的邻接点入度减1，如果入度减1后为0，入队
        while(!q.isEmpty()) {
            int cur = q.poll();
            numCourses--;
            for(int x : g[cur]) {
                if(--d[x] == 0) {
                    q.offer(x);
                }
            }
        }

        // 如果最后队列为空，判断节点数量是否为0，不为0表示有环
        return numCourses == 0;
    }
}
```

