#### [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

**示例 1:**

```
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```

说明：

- 用返回一个整数列表来代替打印
- n 为正整数

**思路一**

我们可以发现的是：输入的数字n与数组的末尾元素m的关系：$$m = 10^n -1$$

因此，我们可以创建m长度的数组，因为数组从1开始，依次将数填入即可。

【大数越界问题】：当n较大时，m会超出int32整型的取值范围，本题中要求返回int类型数组，故不考虑大数越界问题，默认都在取值范围内。

m的算法可以使用pow函数，也可以自己写一个：

```java
    public int[] printNumbers(int n) {  
        int base = 1;
        while(n-->0) base*=10;
        int[] ans = new int[base-1];
        for(int i = 0; i < base-1 ;i++){
            ans[i] = i+1;
        }
        return ans;
    }
```

**拓展：**参考[剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/)

本质上就是将字符全排列的问题，n位数代表需要有n个字符来表示，最后将字符拼接。

假设n为2，如果不进行任何操作，最后将会得到的是 `00,01,01...09,10,11...99`，我们可以发现离我们的答案其实只差前面的0的部分，如何删去0呢，下面是我的做法，仅供参考：

```java
//去零操作
int k = 0;
while(k < num.length && num[k] == '0') k++;
int number = -1;
if(k!=num.length) {
    String s = String.valueOf(num,k,num.length-k);
    number = Integer.parseInt(s);
}
if(number!= -1) ans[index++] = number; //跳过第一个全零的元素
```

![](img/1.png)

```java
    int[] ans;
    StringBuilder res;
    int index = 0,n;
    char[] num, loop = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
    //n个数字代表有n位,创建n长度数组 num[] x表示给num的第几位固定字符
    public int[] printNumbers(int n) {
        this.n = n;
        res = new StringBuilder();
        ans = new int[(int) Math.pow(10, n) - 1];
        num = new char[n];
        dfs(0);
        return ans;
    }

    void dfs(int x) {
        if (x == n) {//表示位数固定完毕,num[] 上所有的字符已经固定,可以返回上次层递归

            //去零操作
            int k = 0;
            while(k < num.length && num[k] == '0') k++;
            int number = -1;
            if(k!=num.length) {
                String s = String.valueOf(num,k,num.length-k);
                number = Integer.parseInt(s);
            }
            if(number!= -1) ans[index++] = number; //跳过第一个全零的元素
            return;
        }
        for (char i : loop) {
            num[x] = i;//每一种情况只需要将对应位置上的数覆盖即可。
            dfs(x + 1);
        }
    }
```

