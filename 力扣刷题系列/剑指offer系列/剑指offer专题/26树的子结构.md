#### 【题目描述】

---

#### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

文中图片来源：[https://krahets.gitee.io/](https://krahets.gitee.io/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

**示例 1：**

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

**示例 2：**

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

**限制：**

```
0 <= 节点个数 <= 10000
```

#### 【思考】

![](img\4.png)

**一、递归方式**

这道题的需要判断：**B是不是A的子结构**。

我们需要考虑以下几点：

1. 空树不是任意一个子树的子结构，也就是说无论A还是B，如果为root == null，则返回false。
2. 如果B是A的子结构，那么A中任意一个节点都可能与B的root相等。【我们先固定A中的一点，然后同时遍历A和B，找到对应目标】
   1. 看看B是不是以A为root的子结构，即调用`isPart(A,B)`。
   2. 看看B是不是以A的左子树或右子树的子结构，即`isSubStructure(A.left,B)|| isSubStructure(A.right,B)`。

**我们借助isPart递归：**

1. **递归的终止条件**：
   1. 当B为空时，表示B已经越过叶子节点，返回true。
   2. 当A为空时，表示A已经越过叶子节点，返回false。
   3. 当节点A与B的值不同时，返回false。
2. **如何递推**：
   1. 分别看看A和B左右两边是不是满足条件：`isPart(a.left,b.left) && isPart(a.right,b.right)`
3. **返回值如何**：返回这个boolean值就可以了。

```java
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(A  == null || B == null) return false;
        if( isPart(A,B)) return true;
        return isSubStructure(A.left,B)|| isSubStructure(A.right,B);//看看左右两边
    }

    boolean isPart(TreeNode a , TreeNode b){
        if( b == null) return true;
        if( a == null || a.val!=b.val) return false;
        return isPart(a.left,b.left) && isPart(a.right,b.right);//同时遍历两边
    }
```

时间复杂度：o(mn)，m，n分别为节点A和B的数量。

空间复杂度：o(m)，m为A树的节点数量。

