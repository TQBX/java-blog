# 数组部分

## [724. 寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)

给定一个整数类型的数组 `nums`，请编写一个能够返回数组 **“中心索引”** 的方法。

我们是这样定义数组 **中心索引** 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

**示例 1：**

```
输入：
nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。
同时, 3 也是第一个符合要求的中心索引。
```

**示例 2：**

```
输入：
nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心索引。
```

 

**说明：**

- `nums` 的长度范围为 `[0, 10000]`。
- 任何一个 `nums[i]` 将会是一个范围在 `[-1000, 1000]`的整数。

### 前缀和

- S 是数组的和，当索引 i 是中心索引时，位于 i 左边数组元素的和 leftsum 满足 S - nums[i] - leftsum。
- 我们只需要判断当前索引 i 是否满足 leftsum==S-nums[i]-leftsum 并动态计算 leftsum 的值。

```java
    public int pivotIndex(int[] nums) {
        int sum = 0, leftsum = 0;
        // 预处理前缀和数组
        for (int x: nums) sum += x;
        for (int i = 0; i < nums.length; ++i) {
            if (leftsum == sum - leftsum - nums[i]) return i;
            leftsum += nums[i];
        }
        return -1;
    }
```

## [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2:**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```

### 二分查找

```java
    public int searchInsert(int[] nums, int target) {
        if(target > nums[nums.length - 1]) return nums.length;
        // 找到第一个大于等于target的位置
        int l = 0, r = nums.length - 1;
        while(l < r){
            // 针对溢出
            int mid = l + r >>> 1;
            if(nums[mid] >= target){
                r = mid;
            }else{
                l = mid + 1;
            }
        }
        return l;
    }
```

## [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

给出一个区间的集合，请合并所有重叠的区间。

 

**示例 1:**

```
输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2:**

```
输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**注意：**输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。

**提示：**

- `intervals[i][0] <= intervals[i][1]`

```java
    public int[][] merge(int[][] nums) {
        int n = nums.length;
        if(n < 2) return nums;
        // 按照左端点升序
        Arrays.sort(nums, (o1, o2) -> (o1[0] - o2[0]));
        List<int[]> res = new ArrayList<>();
        for(int i = 0; i < n; i ++){
            int l = nums[i][0], r = nums[i][1];
            // res中没有数组或最后一个数组的右边界小于当前左边界，视为没有重合
            if(res.size() == 0 || res.get(res.size() - 1)[1] < l) res.add(new int[]{l , r});
            // 有重合，更新右边界
            else res.get(res.size() - 1)[1] = Math.max(res.get(res.size() - 1)[1],r);
        }
        // list快速转换为数组的方法
        return res.toArray(new int[res.size()][]);
    }
```

# 二维数组部分

## [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

给定一个 *n* × *n* 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

**说明：**

你必须在**[原地](https://baike.baidu.com/item/原地算法)**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。

**示例 1:**

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2:**

```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

```java
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        //转置
        /*
         1 2 3  --> 1 4 7
         4 5 6  --> 2 5 8
         7 8 9  --> 3 6 9
        */
        for(int i = 0; i < n; i ++){
            for(int j = i; j < n; j ++){
                swap(matrix, i, j, j, i);
            }
        }
        /*
         1 4 7  --> 7 4 1
         2 5 8  --> 8 5 2
         3 6 9  --> 9 6 3
        */
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < n / 2; j ++){
                swap(matrix, i, j, i, n - j - 1);
            }
        }
    }
    void swap(int[][] m, int i1, int j1, int i2, int j2){
        int temp = m[i1][j1];
        m[i1][j1] = m[i2][j2];
        m[i2][j2] = temp;
    }
```

## [面试题 01.08. 零矩阵](https://leetcode-cn.com/problems/zero-matrix-lcci/)

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

 

**示例 1：**

```
输入：
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出：
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

**示例 2：**

```
输入：
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出：
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

```java
 	public void setZeroes(int[][] matrix) {
        int lenx = matrix.length, leny = matrix[0].length;
        boolean[] row = new boolean[lenx], col = new boolean[leny];
        for (int i = 0; i < lenx; i++)
            for (int j = 0; j < leny; j++)
                if (matrix[i][j] == 0) {
                    row[i] = true;
                    col[j] = true;
                }
        for (int i = 0; i < lenx; i++)
            for (int j = 0; j < leny; j++)
                if (row[i] || col[j])
                    matrix[i][j] = 0;
    }
```

## [498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)

给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

**示例:**

```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

解释:
```

 

**说明:**

1. 给定矩阵中的元素总数不会超过 100000 。

```java
    public int[] findDiagonalOrder(int[][] matrix) {

        if (matrix == null || matrix.length == 0) 
            return new int[0]; 

        int M = matrix.length;
        int N = matrix[0].length;
        List<Integer> list = new ArrayList<Integer>();

        for (int sum = 0; sum < M + N - 1; sum++) {
            if (sum % 2 == 1) {
                // 向下
                for (int i = sum < N ? 0 : sum - N + 1;
                     i <= Math.min(sum, M - 1); i++) {
                    list.add(matrix[i][sum - i]);
                }
            } else {
                // 向上
                for (int i = sum < M ? 0 : sum - M + 1;
                     i <= Math.min(sum, N - 1); i++) {
                    list.add(matrix[sum - i][i]);
                }
            }
        }
        
        int[] result = new int[M * N];
        for (int i = 0; i < list.size(); i++)  
            result[i] = list.get(i); 
        return result;
    }
```



