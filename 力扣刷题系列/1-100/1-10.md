[toc]

## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

### 哈希表

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        //将寻找 target - x 的值降到O(1)
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i ++){
            if(map.containsKey(nums[i])) 
                return new int[]{i , map.get(nums[i])};
            else map.put(target - nums[i] , i);
        }
        return new int[2];
    }
}
```

时间复杂度：O(N)

空间复杂度：O(N)

## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例：**

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1, q = l2, curr = dummyHead;
    int carry = 0;
    while (p != null || q != null) {
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        if (p != null) p = p.next;
        if (q != null) q = q.next;
    }
    //判断最后一位进位
    if (carry > 0) {
        curr.next = new ListNode(carry);
    }
    return dummyHead.next;
}
```

## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

```java
    //滑动窗口
	public int lengthOfLongestSubstring(String s) {
        int ans = 0;
        //hash记录字符和其出现的位置
        Map<Character,Integer> hash = new HashMap<>();
        //i左边界 j有边界
        for(int i = 0, j = 0; j < s.length(); j ++){
            //如果发现当前的字符已经出现过，更新最近出现过的字符
            if(hash.containsKey(s.charAt(j))){
                i = Math.max(i , hash.get(s.charAt(j)) + 1);
            }
            //将当前字符加入
            hash.put(s.charAt(j), j);
            //j-i+1 是无重复字符串的长度
            ans = Math.max(ans, j - i + 1);
        }
        return ans;
    }
```

## [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

给定两个大小为 m 和 n 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的中位数。

**进阶：**你能设计一个时间复杂度为 `O(log (m+n))` 的算法解决此问题吗？

 

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

### 合并数组

```java
//O(M + N) 解法
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        //归并排序
        int a = nums1.length,b = nums2.length;
        int sum = a + b;
        int[] res = new int[sum];
        int p = 0, q = 0, m = 0;
        while(p < a && q < b){
            if(nums1[p] <= nums2[q]) res[m++] = nums1[p++];
            else res[m++] = nums2[q++];
        }
        while(p < a) res[m++] = nums1[p++];
        while(q < b) res[m++] = nums2[q++];
		//区分个数奇偶性
        if(sum % 2 == 0) return (res[sum / 2 - 1] + res[sum / 2]) / 2.0;
        else return res[sum / 2] * 1.0;
    }
}
```

### 二分解法

O(M + N) 的解法参考官方题解：[https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
         * 这里的 "/" 表示整除
         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
         * 这样 pivot 本身最大也只能是第 k-1 小的元素
         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
         */

        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            // 边界情况
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }
            
            // 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例 1：**

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

### 暴力枚举

```java
//O(N^3)的解法
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) return s;
        int maxLen = 1, begin = 0;
        char[] chs = s.toCharArray();
        //枚举所有长度大于1 的子串
        for(int i = 0; i < len - 1; i ++){
            for(int j = i + 1; j < len; j ++){
                if(j - i  + 1 > maxLen && check(chs, i , j)){
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
    //检查是否是回文
    boolean check(char[] chs, int i , int j){
        while(i < j){
            if(chs[i] != chs[j]) return false;
            i ++; j --;
        }
        return true;
    }
}
```

### 动态规划

`dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]`

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if( len < 2) return s;
        int maxLen = 1, begin = 0;
        boolean[][] f = new boolean[len][len];
        char[] chs = s.toCharArray();

        for(int i = 0; i < len; i ++) f[i][i] = true;
        for(int j = 1; j < len; j ++){
            for(int i = 0; i < j; i ++){
                if(chs[i] != chs[j]) f[i][j] = false;
                else{
                    //j - i < 3意味着f[i + 1][j - 1]不构成区间，一定是回文
                    if(j - i < 3) f[i][j] = true;
                    else f[i][j] = f[i + 1][j - 1];
                }

                if(f[i][j] && j - i + 1 > maxLen){
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin , begin + maxLen);
    }
}
```

### 中心扩散

枚举可能出现回文子串的中心位置，从中心位置尽可能扩散出去，得到回文串。

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) return s;

        int maxLen = 1;
        String res = s.substring(0 , 1);
        //枚举每个可能作为中心位置的索引
        for(int i = 0; i < len - 1; i ++){
            //适应奇数情况，中心是一个字符
            String oddStr = centerSpread(s , i , i);
            //适应偶数情况，中心是一段间隙
            String evenStr = centerSpread(s, i , i + 1);
            String maxLenStr = oddStr.length() > evenStr.length() ? oddStr: evenStr;
            if(maxLenStr.length() > maxLen){
                maxLen = maxLenStr.length();
                res = maxLenStr;
            }
        }
        return res;
    }
	//得到l，r间隙为中心位置的回文串
    String centerSpread(String s, int l, int r){
        int len = s.length();
        int i = l, j  = r;
        while(i >= 0 && j < len){
            if(s.charAt(i) == s.charAt(j)){
                i --;j ++;
            }else break;
        }
        return s.substring(i + 1, j);
    }
}
```

## [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"LEETCODEISHIRING"` 行数为 3 时，排列如下：

```
L   C   I   R
E T O E S I I G
E   D   H   N
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"LCIRETOESIIGEDHN"`。

请你实现这个将字符串进行指定行数变换的函数：

```
string convert(string s, int numRows);
```

**示例 1:**

```
输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
```

**示例 2:**

```
输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
```

### 找规律

```java
class Solution {
    public String convert(String s , int n){
        if( n == 1) return s;
        StringBuilder res = new StringBuilder();
        for(int i = 0; i < n; i++){
            if( i == 0 || i == n - 1){
                for(int j = i;j < s.length();j += 2 * (n - 1)) 
                    res.append(s.charAt(j));
            }else{
                for(int j = i, k = 2 * (n - 1) - i;
                    j < s.length() || k < s.length();
                    j += 2 * (n - 1), k += 2 * (n - 1)){
                    if(j < s.length()) res.append(s.charAt(j));
                    if(k < s.length()) res.append(s.charAt(k));
                }
            }
        }
        return res.toString();
    }
}
```

```java
class Solution {
    public String convert(String s, int numRows) {
        if(numRows < 2) return s;
        List<StringBuilder> rows = new ArrayList<StringBuilder>();
        for(int i = 0; i < numRows; i++) rows.add(new StringBuilder());
        int i = 0, flag = -1;
        for(char c : s.toCharArray()) {
            rows.get(i).append(c);
            //到顶了
            if(i == 0 || i == numRows -1) flag = - flag; 
            i += flag;
        }
        StringBuilder res = new StringBuilder();
        for(StringBuilder row : rows) res.append(row);
        return res.toString();
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/zigzag-conversion/solution/zzi-xing-bian-huan-by-jyd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

**示例 1:**

```
输入: 123
输出: 321
```

 **示例 2:**

```
输入: -123
输出: -321
```

**示例 3:**

```
输入: 120
输出: 21
```

**注意:**

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

```java
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while(x != 0){
            int pop = x % 10;
            x /= 10;
            //边界溢出判断
            if (rev > Integer.MAX_VALUE / 10 || 
                (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if (rev < Integer.MIN_VALUE / 10 || 
                (rev == Integer.MIN_VALUE / 10 && pop < -8))return 0;
            rev = rev * 10 + pop;  
        }
        return rev;
    }
}
```

## [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：

- 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
- 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
- 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0 。

**提示：**

- 本题中的空白字符只包括空格字符 `' '` 。
- 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

 

**示例 1:**

```
输入: "42"
输出: 42
```

**示例 2:**

```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

**示例 3:**

```
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

**示例 4:**

```
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```

**示例 5:**

```
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
```

```java

public int myAtoi(String str) {
    if(str == null || str.length() == 0) return 0;
    int k = 0;
    boolean isNeg = false;
    while(k < str.length() && str.charAt(k) == ' ') k++; //跳过开头的空格
    if(k == str.length()) return 0; // 字符串本身为 ' '的情况
    long res = 0;
    char c = str.charAt(k); //判断 第一位是否为 + -
    if(c == '-'){
        isNeg = true;
        k++;
    }else if( c == '+'){
        k++;
    }
    //计算数字
    while(k < str.length() && str.charAt(k) >= '0' && str.charAt(k) <= '9'){ 
        res = res *  10 + str.charAt(k++) -'0';
        //这里需要终止，因为再加可能会溢出
        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE)  break;

    }
    if(isNeg) res = res * -1;
    if(res < Integer.MIN_VALUE) return Integer.MIN_VALUE;
    if(res > Integer.MAX_VALUE) return Integer.MAX_VALUE;
    return (int)res;
}

```

## [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**

```
输入: 121
输出: true
```

**示例 2:**

```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3:**

```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

**进阶:**

你能不将整数转为字符串来解决这个问题吗？

```java
class Solution {
    public boolean isPalindrome(int x) {
        if( x < 0) return false;
        int num = x , temp = 0;
        while(num != 0){
            int c = num % 10;
            num /= 10;
            temp = temp * 10 + c;
        }
        return x  ==  temp;      
    }
}
```

## [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

```
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
```

所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

[https://leetcode-cn.com/problems/regular-expression-matching/solution/shi-pin-tu-jie-dong-tai-gui-hua-zheng-ze-biao-da-s/](https://leetcode-cn.com/problems/regular-expression-matching/solution/shi-pin-tu-jie-dong-tai-gui-hua-zheng-ze-biao-da-s/)

```java
class Solution {
    public boolean isMatch(String s, String p) {

        boolean table[][] = new boolean[s.length() + 1][p.length() + 1];

        table[0][0] = true;

        for (int col=1; col<table[0].length; col++) {
            char ch = p.charAt(col-1);
            if (col > 1) {
                if (ch == '*') {
                    table[0][col] = table[0][col-2]; 
                } else {
                    table[0][col] = false;
                }
            } else {
                if (ch == '*') {
                    table[0][col] = true;
                }
            }
        }

        for (int row=1; row<table.length; row++) {
            char ch1 = s.charAt(row-1);
            for (int col=1; col<table[row].length; col++) {
                char ch2 = p.charAt(col-1);
                if (ch1==ch2 || ch2 == '.') {
                    table[row][col] = table[row-1][col-1];
                } else if (ch2 == '*') {
                    if(col > 1) {
                        if (table[row][col-2]) {
                            table[row][col] = true; // * 前面的字符出现0次
                        } else {
                            char prev = p.charAt(col-2);
                            if (prev== ch1 || prev == '.') {
                                table[row][col] = table[row - 1][col]; // * 前面的字符出现多次
                            }
                        }

                    }
                }
            }
        }


        boolean lastRow[] = table[table.length-1];
        return lastRow[lastRow.length-1];
    }
}

作者：alchemist-5r
链接：https://leetcode-cn.com/problems/regular-expression-matching/solution/shi-pin-tu-jie-dong-tai-gui-hua-zheng-ze-biao-da-s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

