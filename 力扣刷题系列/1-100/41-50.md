## [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

**示例 1:**

```
输入: [1,2,0]
输出: 3
```

**示例 2:**

```
输入: [3,4,-1,1]
输出: 2
```

**示例 3:**

```
输入: [7,8,9,11,12]
输出: 1
```

**提示：**

你的算法的时间复杂度应为O(*n*)，并且只能使用常数级别的额外空间。

### 哈希表法

```java
	// 时间复杂度 O(N) 空间复杂度 O(N)
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;

        Set<Integer> set = new HashSet<>();
        for(int num : nums) set.add(num);
        for(int i = 1;  i <= n; i ++){
            if(!set.contains(i)) return i;
        }
        return n + 1;
    }
```

### 排序法

```java
    // 时间复杂度 O(Nlog(N)) 空
    public int firstMissingPositive(int[] nums) {
        // 先排序 Nlog(N)
        Arrays.sort(nums);

        int pre = 0;
        for(int i = 0; i < nums.length; i ++){
            // 跳过非正整数和重复值
            if(nums[i] <= 0 || nums[i] == pre) continue;
            // 找到第一个突变的元素
            else if(nums[i] > pre + 1) break;

            pre ++;
        }
        return pre + 1;
    }
```

### 原地哈希法

![](https://pic.leetcode-cn.com/1e4f3f1c9a6fb37c2aa515069508f5f3ef9d72cc55b586790f9bec9705052d17-0041-14.png)

```java
	// 时间复杂度 O(N) 空间复杂度 O(1)
    // 原地哈希： 自定义哈希函数 将数值 i 映射到 i - 1的位置上
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        for(int i = 0; i < len; i ++){
            // 在指定范围内， 且没有放在正确位置上， 交换
            while(nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]){
                swap(nums, nums[i] - 1, i);
            }
        }
        // 找到不符合的位置
        for(int i = 0; i < len; i ++){
            if(nums[i] != i + 1) return i + 1;
        }
        // 都正确则返回数组长度 + 1
        return len + 1;
    }
    void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

## [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。

**示例:**

```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

### 暴力求解

```java
    // 时间复杂度 O(N^2)
	public int trap(int[] height) {
        int res = 0;
        // 遍历每一列柱子
        for(int i = 1; i < height.length - 1; i ++){
            // 分别记录当前柱子向左 向右的最大高度
            int leftMax = 0, rightMax = 0;
            for(int j = 0; j <= i; j ++) 
                leftMax = Math.max(leftMax, height[j]);
            for(int j = i; j < height.length; j ++) 
                rightMax = Math.max(rightMax, height[j]);
			// 当前位置 water[i] = min(max(h[0->i], h(i->len-1))) - h[i]
            res += Math.min(leftMax, rightMax) - height[i];
        }
        return res;
    }
```

### 动态规划

```java
    // 时间复杂度 优化至 O(N) , 但空间复杂度为 O(N)
	public int trap(int[] height) {
        if(height.length == 0) return 0;
        int n = height.length;
        // 优化方案： 创建两个备忘录，分别记录leftMax 和 rightMax
        int[] leftMax = new int[n];
        int[] rightMax = new int[n];
        int res = 0;
        // 初始化
        leftMax[0] = height[0];
        rightMax[n - 1] = height[n - 1];
        for(int i = 1; i < n; i ++) 
            leftMax[i] = Math.max(height[i], leftMax[i - 1]);
        for(int i = n - 2; i >= 0; i --) 
            rightMax[i] = Math.max(height[i] , rightMax[i + 1]);
        for(int i = 1; i < n - 1; i ++) 
            res += Math.min(leftMax[i], rightMax[i]) - height[i];
        return res;
    }
```

### 双指针

```java
	// 时间复杂度 O(N) 空间 O(1)
	// 省去创建备忘录的空间， 边走变算
    public int trap(int[] height) {
        if(height.length == 0) return 0;
        int n = height.length;
        int l = 0, r = height.length - 1, res = 0;
        int leftMax = height[0], rightMax = height[n - 1];
        while(l <= r){
            leftMax = Math.max(leftMax, height[l]);
            rightMax = Math.max(rightMax, height[r]);
            if(leftMax < rightMax) 
                res += leftMax - height[l ++];
            else 
                res += rightMax - height[r --];
        }
        return res;
    }
```

## [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**示例 1:**

```
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2:**

```
输入: num1 = "123", num2 = "456"
输出: "56088"
```

**说明：**

1. `num1` 和 `num2` 的长度小于110。
2. `num1` 和 `num2` 只包含数字 `0-9`。
3. `num1` 和 `num2` 均不以零开头，除非是数字 0 本身。
4. **不能使用任何标准库的大数类型（比如 BigInteger）**或**直接将输入转换为整数来处理**。

```java
/**
num1的第i位(高位从0开始)和num2的第j位相乘的结果在乘积中的位置是[i+j, i+j+1]
例: 123 * 45,  123的第1位 2 和45的第0位 4 乘积 08 存放在结果的第[1, 2]位中
          index:    0 1 2 3 4  

                        1 2 3
                    *     4 5
                    ---------
                          1 5
                        1 0
                      0 5
                    ---------
                      0 6 1 5
                        1 2
                      0 8
                    0 4
                    ---------
                    0 5 5 3 5
这样我们就可以单独都对每一位进行相乘计算把结果存入相应的index中        
**/
public String multiply(String num1, String num2) {
    int m = num1.length(), n = num2.length();
    // 记录每位数字的数组
    int[] arr = new int[m + n];
    // 从个位开始计算
    for(int i = m - 1; i >= 0; i --){
        for(int j = n - 1; j >= 0; j --){
            // i+j, i+j+1
            int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
            int p1 = i + j, p2 = i + j + 1;
            // 本身乘积 + 原来的数
            int sum = mul + arr[p2];
            // 取个位
            arr[p2] = sum % 10;
            // 进位
            arr[p1] += sum / 10;
        }
    }
    // 移除前导零，只需记录第一个非0的位置即可
    int i = 0;
    while(i < arr.length && arr[i] == 0) i ++;
    if(i == arr.length) return "0";
    StringBuilder res = new StringBuilder();
    while(i < arr.length){
        res.append(arr[i]);
        i ++;
    }
    return res.toString();
}
```

