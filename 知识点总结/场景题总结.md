# 故障排查类

## 线上故障排查

硬件故障排查：如果一个实例发生了问题，根据情况选择，要不要着急去重启。如果出现的CPU、内存飙高或者日志里出现了OOM异常

1. 隔离：把这台机器从请求列表里摘除，比如把nginx相关权重设置为0

2. 保留现场：

   1. 系统当前连接：ss -antp > $DUMP_DIR/ss.dump 2>&1

   2. 网络状态统计：netstat -s > $DUMP_DIR/netstat-s.dump 2>&1

   3. 进程资源：ss -antp > $DUMP_DIR/ss.dump 2>&1

   4. cpu资源：

      `mpstat > $DUMP_DIR/mpstat.dump 2>&1`
      `vmstat 1 3 > $DUMP_DIR/vmstat.dump 2>&1`
      `sar -p ALL > $DUMP_DIR/sar-cpu.dump 2>&1`
      `uptime > $DUMP_DIR/uptime.dump 2>&1`

   5. IO资源：iostat -x > $DUMP_DIR/iostat.dump 2>&1

   6. 内存问题：free -h > $DUMP_DIR/free.dump 2>&1

   7. 其他全局：ps -ef 、dmesg、sysctl -a

   8. 进程快照：`${JDK_BIN}jinfo $PID > $DUMP_DIR/jinfo.dump 2>&1`

   9. jstat堆信息：

      `${JDK_BIN}jstat -gcutil $PID > $DUMP_DIR/jstat-gcutil.dump 2>&1`
      `${JDK_BIN}jstat -gccapacity $PID > $DUMP_DIR/jstat-gccapacity.dump 2>&1`

   10. jmap堆信息：`jmap $PID / jmap -heap / jmap -histo / jmap -dump:format=b,file=heap.bin $PID`
   11. jvm执行栈：jstack $PID
   12. 高级替补：kill -3 $PID
   13. 内存泄漏现象：9版本中，jmap被jhsdb jmap替代

3. 问题排查

## 内存溢出

使用jmap命令，导出了一份线上堆栈

使用MAT进行分析，通过对GC Roots的分析，发现了一个非常大的HashMap对象，这个原本是做缓存用的，但是使用了无界缓存，没有设置超时时间orLRU策略，使用上没有重写key对象的hashcode和equals方法，对象无法取出直接造成堆内存占用一直上升。

解决：缓存改为guava的cache，并设置弱引用

内存溢出是一个结果，内存泄漏是原因。

内存溢出的原因有：内存空间不足，配置错误等。一些错误的编程方式，不再被使用的对象，没有被回收，没有及时切断和gc roots的联系，导致内存泄漏。

## CPU飙高

线上应用，单节点运行一段时间后，cpu飙升，怀疑某个业务逻辑计算量大 or 出发死循环，排查到最后发现是gc问题

1. 使用top，查找使用cpu最多的某个进程，记录pid
2. 找到进程中使用cpu最多的某个线程
3. jstack

# 场景算法

## URL 黑名单

100亿。黑名单url，每个64B，怎么存，怎么判断一个url是否在黑名单中？

- hashmap：太大了 需要 640G
- bloom filter：判断一个元素是否在集合中，bitmap
  - K个hash函数对元素值进行k次计算，得到k个hash值
  - 根据得到的哈希值，在数组的对应下标处置1

## 题目描述

给定a，b两个文件，各存放50亿各URL，每个URL各占64B，内存限制是4G。请找出a，b两个文件共同的URL。

## 解答思路

每个URL占64B，50亿个URL占用的空间大小约为320GB。

$$
5,000,000,000 * 64B \approx 5GB * 64 = 320GB
$$
内存大小只有4GB，因此，我们不可能一次性把所有URL加载到内存中处理，我们可以采用分治的思路：

> 把一个文件中的URL按照某个特征划分为多个小文件，使得每个小文件大小不超过4G，这样就可以分别将这些小文件读到内存中进行处理。

- 首先遍历文件a，对遍历的URL求$$hash(URL) \% 1000$$，根据计算结果把遍历到的URL存储到$$a_0，a_1，a_2……a_{999}$$，这样每个大小约为300MB。
- 使用同样的方法遍历文件b，同样把文件b中的URL分别存储文件$$b_0，b_1，b_2，……b_{999}$$中。
- 处理过后，所有可能相同的URL都在对应的小文件中，即$$a_0$$对应$$b_0$$，$$a_n$$对应$b_n$，$n \in [0, 999]$。不对应的小文件不可能有相同的URL，接下来我们只需要求出这1000对文件中相同的URL即可。
- 遍历$a_i(i \in [0, 999])$，将URL存储到一个HashSet中，然后遍历$b_i(i \in [0, 999])$，中的每个URL，看在HashSet集合中是否存在，若存在，说明是共同的URL，可以把这个URL保存到一个单独的文件中。



在库存扣减（例如电商购物、秒杀活动）场景中，选择使用 Redis 的 `DECR` 操作或直接使用数据库进行库存扣减，各有优劣。下面从多个角度对这两种方案进行详细比较，以帮助决策。

## 一、性能

### **Redis 的 DECR 操作**

- **高性能**：Redis 是基于内存的键值存储，读写速度极快，单机可达十万级别的 QPS（每秒查询率）。
- **原子性操作**：`DECR` 是 Redis 提供的原子性递减操作，确保了并发情况下数据的正确性。
- **低延迟**：内存操作的延迟通常在微秒级别，远低于磁盘 I/O。

### **数据库操作**

- **相对较慢**：数据库操作涉及磁盘 I/O、日志写入等，延迟一般在毫秒级别。
- **并发性能有限**：传统关系型数据库在高并发情况下，可能出现锁争用、事务冲突等问题，影响性能。
- **优化空间**：可以通过索引优化、读写分离、分库分表等方式提升性能，但实现复杂度较高。

## 二、数据一致性

### **Redis 的 DECR 操作**

- **弱一致性**：Redis 默认是内存存储，若未开启持久化（RDB、AOF），在意外宕机时可能导致数据丢失。
- **数据持久化**：即使开启了持久化，Redis 的数据一致性依然可能受到 RDB 快照间隔、AOF 重写等因素影响。
- **主从复制延迟**：在集群模式下，主从节点之间可能存在数据同步延迟，导致读到旧数据。

### **数据库操作**

- **强一致性**：关系型数据库遵循 ACID 特性，通过事务机制确保数据的一致性和完整性。
- **事务支持**：可以使用事务隔离级别、锁机制等确保并发操作下的数据正确性。
- **持久化保障**：数据持久化到磁盘，即使发生系统故障，也可通过日志和备份进行恢复。

## 三、实现复杂度

### **Redis 的 DECR 操作**

- **实现简单**：直接调用 `DECR` 命令即可完成库存扣减，代码简单明了。
- **额外机制需求**：需要设计缓存失效策略、数据同步机制，以确保 Redis 和数据库之间的数据一致性。
- **防止超卖**：需要在 Redis 层面增加逻辑，防止库存被扣减到负数。

### **数据库操作**

- **实现复杂**：需要考虑事务、锁、并发控制等，防止出现超卖、死锁等问题。
- **数据一致性保障**：由于库存数据与业务数据在同一数据库中，数据一致性管理相对简单。
- **业务逻辑集中**：所有数据操作都在数据库中完成，方便维护和管理。

## 四、扩展性

### **Redis 的 DECR 操作**

- **水平扩展**：Redis 支持分片和集群模式，便于扩展以支持更高的并发量。
- **可用性高**：通过哨兵模式或集群模式，可以实现高可用和故障自动转移。
- **热点问题**：高并发情况下，可能出现热点键，需采用一致性哈希等策略分散压力。

### **数据库操作**

- **扩展性有限**：关系型数据库的水平扩展较为困难，通常需要进行分库分表，增加了系统复杂度。
- **读写分离**：可以通过读写分离提高读性能，但写性能的提升有限。
- **中间件支持**：需要引入分布式事务、中间件等，增加系统复杂度和维护成本。

## 五、可靠性和容灾

### **Redis 的 DECR 操作**

- **数据丢失风险**：如果未开启持久化或持久化策略不当，Redis 宕机可能导致数据丢失。
- **容灾难度**：在多地部署时，需要考虑 Redis 数据同步的实时性和一致性。
- **数据恢复复杂**：Redis 的数据恢复可能涉及复杂的主从同步、AOF 日志重写等过程。

### **数据库操作**

- **高可靠性**：数据库通常有完善的备份、日志和恢复机制，数据可靠性高。
- **容灾方案成熟**：可以通过主从复制、双活、异地多活等方式实现容灾。
- **数据恢复便捷**：出现故障时，可以通过事务日志、备份文件快速恢复数据。

## 六、业务需求匹配

### **Redis 的 DECR 操作**

- **高并发秒杀场景**：适用于短时间内有大量并发请求的场景，如秒杀、抢购活动。
- **缓存层优化**：适合作为缓存层，减轻数据库压力，提高系统整体性能。
- **实时性要求高**：需要极低的响应延迟，提升用户体验。

### **数据库操作**

- **常规库存管理**：适用于日常的库存扣减操作，业务流程稳定。
- **数据分析需求**：库存变动数据需要长期保存，供后续统计、分析、审计等。
- **复杂业务逻辑**：涉及多表关联、复杂事务的场景，数据库操作更为合适。

## 七、成本考虑

### **Redis 的 DECR 操作**

- **内存成本高**：Redis 基于内存存储，内存成本相对较高。
- **运维成本**：需要专业的 Redis 运维人员，监控和管理 Redis 集群。
- **硬件投入**：为支持高并发，可能需要投入更多的服务器资源。

### **数据库操作**

- **硬件成本**：磁盘存储成本低于内存，但在高并发场景下，可能需要高性能的硬件支持。
- **运维复杂度**：数据库的运维、调优需要专业技能，但相关经验和工具较为丰富。
- **成本平衡**：通过合理的架构设计，可以在性能和成本之间取得平衡。

## 八、综合对比表

| 比较维度       | Redis 的 DECR 操作                       | 数据库操作                         |
| -------------- | ---------------------------------------- | ---------------------------------- |
| **性能**       | 高，适合高并发、低延迟                   | 较低，需优化才能支持高并发         |
| **一致性**     | 弱一致性，需额外机制保障                 | 强一致性，事务保障数据正确性       |
| **实现复杂度** | 代码简单，需处理数据同步和一致性问题     | 代码复杂，但数据管理集中，维护方便 |
| **扩展性**     | 易扩展，支持高并发，需处理热点问题       | 扩展性有限，需引入复杂的分布式方案 |
| **可靠性**     | 需配置持久化和容灾方案，数据丢失风险较高 | 高可靠性，数据持久化和恢复机制完善 |
| **业务匹配度** | 适合高并发、秒杀等场景                   | 适合常规业务、复杂事务场景         |
| **成本**       | 内存成本高，硬件投入大                   | 硬件成本相对较低，运维成本较高     |

## 九、结论和建议

- **选择 Redis 的场景**：
  - **高并发、低延迟**：业务需要承受高并发请求，且对响应速度有极高要求。
  - **可以接受最终一致性**：业务允许在短时间内数据不一致，能够容忍一定程度的超卖风险。
  - **有完善的运维能力**：团队具备 Redis 集群的运维和优化能力，能够处理数据持久化和容灾。
- **选择数据库的场景**：
  - **数据一致性要求高**：业务无法接受超卖、数据丢失等情况，需要强一致性保障。
  - **业务逻辑复杂**：涉及复杂的事务、关联操作，数据库更能满足需求。
  - **长期数据存储**：需要对库存变动进行长期保存，供后续分析和审计。
- **混合方案**：
  - **读写分离**：使用 Redis 作为缓存层，加速读操作，写操作仍由数据库处理。
  - **削峰填谷**：在高并发时段，先使用 Redis 记录操作，待高峰过后再异步同步到数据库。
  - **双写策略**：同时写入 Redis 和数据库，确保数据的一致性和持久性。

## 十、注意事项

- **防止超卖**：无论采用哪种方案，都需要在业务逻辑中防止库存被扣减到负数的情况，可在操作前检查库存量。
- **事务控制**：在数据库中，合理使用事务和锁机制，避免死锁，提高并发性能。
- **数据同步**：如果采用 Redis，需要设计可靠的数据同步策略，确保 Redis 和数据库的数据一致性。
- **监控和报警**：建立完善的监控体系，实时监控库存变化，及时发现和处理异常情况。
- **压测和优化**：在上线前进行压力测试，根据测试结果进行系统优化，确保能够满足预期的并发需求。

## 十一、总结

选择使用 Redis 的 `DECR` 操作还是数据库进行库存扣减，需要根据具体的业务需求、技术能力和成本预算进行综合考虑。Redis 提供了高性能和高并发能力，适合对性能要求极高的场景，但需要付出额外的努力来保证数据的一致性和持久性。数据库操作虽然在性能上不如 Redis，但在数据一致性、可靠性和复杂业务处理上具有优势。对于大多数业务，可能需要结合两种方案的优点，设计出满足自身需求的库存扣减策略。





除了高并发和高性能，在设计和评估系统（特别是库存扣减系统）时，还有许多重要的特性需要考虑。以下是一些关键特性、它们对应的指标，以及这些指标的含义：

## 1. **数据一致性（Data Consistency）**

### **重要性**

确保系统在任何时刻的数据都是正确的，无论在何种并发情况下，数据的完整性和准确性都得到保证。

### **对应指标**

- **一致性级别**：强一致性、弱一致性、最终一致性等。
- **ACID 特性**：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
- **数据冲突率**：并发操作中出现数据冲突的次数或概率。

### **含义**

- **一致性级别**：定义了系统在分布式环境下数据同步的严格程度。
- **ACID 特性**：用于评估数据库事务的可靠性和数据完整性。
- **数据冲突率**：反映并发情况下数据冲突的频率，影响数据一致性。

------

## 2. **可靠性（Reliability）**

### **重要性**

系统在一段时间内无故障运行的能力，直接影响用户体验和业务连续性。

### **对应指标**

- **平均无故障时间（MTBF）**：Mean Time Between Failures。
- **平均修复时间（MTTR）**：Mean Time To Repair。
- **错误率**：单位时间内发生错误的次数。

### **含义**

- **MTBF**：系统在两次故障之间平均能运行多长时间。
- **MTTR**：系统从故障中恢复到正常运行状态所需的平均时间。
- **错误率**：评估系统稳定性，错误率越低，可靠性越高。

------

## 3. **可用性（Availability）**

### **重要性**

系统在需要时能够正常提供服务的能力，通常与可靠性紧密相关。

### **对应指标**

- **可用率**：系统在特定时间段内可用的百分比（如 99.9%、99.99%）。
- **停机时间**：系统不可用的总时间。
- **服务级别协议（SLA）**：与用户或客户约定的服务可用性标准。

### **含义**

- **可用率**：衡量系统稳定提供服务的能力，高可用率意味着更好的用户体验。
- **停机时间**：直接影响业务运营和用户满意度。
- **SLA**：确保服务提供方和使用方对可用性有明确的认知和约定。

------

## 4. **可扩展性（Scalability）**

### **重要性**

系统在处理增长的工作负载时，能够通过增加资源来提升性能的能力。

### **对应指标**

- **水平扩展能力**：通过增加更多的节点来提升性能。
- **垂直扩展能力**：通过提升单个节点的硬件性能来提升性能。
- **扩展效率**：资源增加后性能提升的比例。

### **含义**

- **水平扩展能力**：评估系统在分布式环境下的扩展性。
- **垂直扩展能力**：评估系统在单节点硬件升级后的性能提升潜力。
- **扩展效率**：理想情况下，资源增加一倍，性能也应增加一倍。

------

## 5. **安全性（Security）**

### **重要性**

保护系统和数据免受未经授权的访问、篡改和破坏，确保数据的机密性、完整性和可用性。

### **对应指标**

- **漏洞数量**：系统中存在的安全漏洞数量。
- **入侵检测率**：系统对安全威胁的检测和响应能力。
- **合规性**：符合相关安全标准和法规的程度（如 GDPR、PCI DSS）。

### **含义**

- **漏洞数量**：反映系统的安全风险程度。
- **入侵检测率**：评估系统抵御和发现安全威胁的能力。
- **合规性**：确保系统符合法律法规，降低法律和商业风险。

------

## 6. **可维护性（Maintainability）**

### **重要性**

系统易于维护、升级和修改的能力，直接影响开发和运维效率。

### **对应指标**

- **代码可读性**：代码的清晰度和结构化程度。
- **模块化程度**：系统功能的模块划分和耦合程度。
- **技术债务**：需要重构或改进的代码量。

### **含义**

- **代码可读性**：影响开发人员理解和修改代码的效率。
- **模块化程度**：高模块化有助于独立开发和测试，降低耦合。
- **技术债务**：技术债务过高可能导致维护困难和系统风险增加。

------

## 7. **可测试性（Testability）**

### **重要性**

系统易于测试的程度，影响缺陷发现和质量保障。

### **对应指标**

- **测试覆盖率**：代码被测试的比例。
- **缺陷发现率**：测试中发现的缺陷数量。
- **自动化测试比例**：自动化测试在整个测试套件中的占比。

### **含义**

- **测试覆盖率**：高覆盖率有助于发现潜在问题，提升系统质量。
- **缺陷发现率**：反映测试的有效性和系统的稳定性。
- **自动化测试比例**：提高测试效率和一致性，降低人工成本。

------

## 8. **可用性（Usability）**

### **重要性**

系统对用户的友好程度，包括易用性、可理解性和用户体验。

### **对应指标**

- **用户满意度**：通过调查或评分获得的用户满意程度。
- **任务完成时间**：用户完成特定任务所需的平均时间。
- **用户错误率**：用户在操作过程中发生错误的频率。

### **含义**

- **用户满意度**：直接影响用户留存和口碑。
- **任务完成时间**：评估系统的易用性和效率。
- **用户错误率**：高错误率可能导致用户流失，需要优化用户界面和交互。

------

## 9. **延迟（Latency）**

### **重要性**

从请求发出到收到响应所经历的时间，对实时性要求高的系统尤为重要。

### **对应指标**

- **平均延迟**：所有请求的平均响应时间。
- **P95/P99 延迟**：95% 或 99% 的请求在此延迟时间内完成。
- **最大延迟**：请求的最长响应时间。

### **含义**

- **平均延迟**：整体性能的衡量标准。
- **P95/P99 延迟**：反映极端情况下的性能，影响用户体验。
- **最大延迟**：高最大延迟可能导致用户感知到系统卡顿或无响应。

------

## 10. **吞吐量（Throughput）**

### **重要性**

单位时间内系统处理的请求数量，是衡量系统处理能力的关键指标。

### **对应指标**

- **每秒请求数（RPS/QPS）**：Requests per Second / Queries per Second。
- **数据处理量**：每秒处理的数据量，通常以 MB/s 或 GB/s 表示。
- **事务处理数**：每秒完成的事务数量。

### **含义**

- **RPS/QPS**：评估系统在高负载下的处理能力。
- **数据处理量**：对大数据处理系统尤为重要。
- **事务处理数**：衡量事务型系统的性能，如数据库操作。

------

## 11. **可伸缩性（Elasticity）**

### **重要性**

系统根据负载自动调整资源的能力，确保高负载时性能不下降，低负载时节省资源。

### **对应指标**

- **自动扩展速度**：系统在负载变化时调整资源的速度。
- **资源利用率**：资源的实际使用率，避免资源浪费。
- **扩展成本**：扩展或缩减资源所需的费用。

### **含义**

- **自动扩展速度**：影响系统对突发流量的响应能力。
- **资源利用率**：高利用率提高成本效益。
- **扩展成本**：需要平衡弹性带来的收益和成本。

------

## 12. **可移植性（Portability）**

### **重要性**

系统在不同环境、平台或技术栈中运行的能力，减少对特定环境的依赖。

### **对应指标**

- **跨平台支持**：系统支持的操作系统、硬件架构数量。
- **环境依赖性**：对特定库、框架或服务的依赖程度。
- **迁移成本**：将系统迁移到新环境的难易程度和费用。

### **含义**

- **跨平台支持**：提高系统的适应性，扩大应用范围。
- **环境依赖性**：降低对特定技术的锁定风险。
- **迁移成本**：在需要更换环境时，降低投入和风险。

------

## 13. **兼容性（Compatibility）**

### **重要性**

系统与其他系统、组件或版本协同工作的能力，确保系统间的互操作性。

### **对应指标**

- **向后兼容性**：新版本对旧版本的支持程度。
- **集成能力**：与第三方系统或服务的集成难易程度。
- **标准遵从性**：对行业标准、协议的支持程度。

### **含义**

- **向后兼容性**：降低升级带来的风险和成本。
- **集成能力**：提高系统的生态和互联互通性。
- **标准遵从性**：确保系统的通用性和可扩展性。

------

## 14. **监控和可观测性（Observability）**

### **重要性**

系统提供足够的指标、日志和追踪信息，帮助运维和开发人员理解系统的内部状态和行为。

### **对应指标**

- **指标覆盖率**：关键性能指标（KPIs）的监控覆盖程度。
- **告警及时性**：从问题发生到告警触发的时间。
- **日志完整性**：日志信息的详细程度和准确性。

### **含义**

- **指标覆盖率**：确保对系统健康状态的全面了解。
- **告警及时性**：快速响应和解决问题，减少影响。
- **日志完整性**：辅助故障排查和性能优化。

------

## 15. **成本效益（Cost Efficiency）**

### **重要性**

在满足性能和功能需求的前提下，系统的投入产出比是否合理。

### **对应指标**

- **总拥有成本（TCO）**：Total Cost of Ownership，包括硬件、软件、运营等所有成本。
- **性价比**：性能指标与成本的比值。
- **投资回报率（ROI）**：Return on Investment，衡量投资的收益率。

### **含义**

- **TCO**：帮助企业了解系统的长期投入和运营成本。
- **性价比**：用于比较不同方案的经济性和性能。
- **ROI**：评估项目或系统的投资价值和收益。

## 参考

- 微信公众号：武哥聊编程