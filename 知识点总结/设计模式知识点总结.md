## 单例模式

> 某个类只能生成一个实例，该实例全局访问，例如Spring容器里一级缓存的单例池

1. 构造函数private。
2. 通过一个静态方法或者枚举返回单例对象。
3. 确保多线程环境下单例对象只有一个。
4. 确保单例对象在反序列化时不会重新构建对象。

### 饿汉式

```java
public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return instance;
    }
}
```

### 懒汉式

优点：在使用时才实例化单例，一定程度上节约了资源。

缺点：每次调用getInstance方法都会进行同步，消耗不必要的资源。

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    // synchronized方法,多线程情况下保证单例对象唯一
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 双重检查锁

用双重检查锁的方式实现单例模式：

```java
public class Singleton {
	//注意使用volatile防止指令重排序
    private volatile static Singleton instance;
	//私有化构造方法，单例模式基本操作
    private Singleton() {
    }
	//静态获取单例的方法
    public  static Singleton getInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (instance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

使用`volatile`的原因：防止指令重排序。

> `instance= new Singleton();`这一步，是一个实例化的过程，底层其实分为三部执行：
>
> 1. 为instance分配内存空间：`memory = allocate();`
> 2. 实例化instance。`ctorInstance(memory);`
> 3. 将instance指向分配的内存地址。`instance = memory;`

由于JVM具有指令重排序的特性，指令的执行顺序可能会变成1，3，2。在多线程环境下，可能某个线程可能会得到未初始化的实例。

举个例子：加入线程A执行了1和2之后，线程B调用getInstance的时候，会发现instance不为null，会直接返回这个没有执行过指令3的实例。

### 静态内部类

```java
public class Singleton {
    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }

    /**
     * 静态内部类
     */
    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }
}
```

第一次加载Singleton类时不会初始化实例，只有在第一次调用getInstance方法时，虚拟机才会加载holder。

既保证线程安全，也保证单例对象唯一，也实现延迟初始化。

### 枚举单例

double check和静态内部类的写法都不错，但是都不能防止被反序劣化生成多个实例。

但枚举单例可以！

```java
public enum SingletonEnum {
    INSTANCE;
}
```

默认枚举实例的创建是线程安全的，即使**反序列化**也不会生成新的实例，**任何情况下都是一个单例**。

**为什么枚举实现的单例模式可以防止反序列化攻击？**

> Java规范字规定，**每个枚举类型及其定义的枚举变量在JVM中都是唯一的**，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。**在序列化的时候Java仅仅是将枚举对象的name属性输到结果中，反序列化的时候则是通过java.lang.Enum的valueOf()方法来根据名字查找枚举对象**。也就是说，序列化的时候只将DATASOURCE这个名称输出，反序列化的时候再通过这个名称，查找对应的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。

# 工厂模式

定义一个用于创建产品的接口，由子类决定生产何种产品。

优点：解耦：提供参数即可获取产品，通过配置文件可以不修改代码增加具体产品。

缺点：每增加一个产品就得新增一个产品类

# 抽象工厂模式

提供一个接口，用于创建相关或者依赖对象的家族，并由此进行约束。

优点：可以在类的内部对产品族进行约束

缺点：假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。

# 责任链模式

