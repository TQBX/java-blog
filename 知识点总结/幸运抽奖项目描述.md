# 简历上的写法

该系统采用DDD架构设计，划分为**抽奖活动、抽奖策略、奖品、积分、返利**等领域。代码开发运用多种设计模式，支持多种营销策略，如：用户积分兑换抽奖次数、积分返利等，实现差异化抽奖流程，如：通用抽奖、黑名单、抽奖N次解锁奖品范围、消耗积分解锁奖品等各类玩法，并对抽奖的计算和秒杀做了设计优化。

- 根据不同的抽奖玩法，将抽奖流程抽象为**抽奖前后两阶段抽奖**。运用模版模式、工厂模式定义通用抽奖流程，抽奖前采用责任链完成黑名单、奖品权重过滤，采用自定义规则树对抽奖后的动作的次数和库存信息进行动态处理，实现差异化抽奖。
- 考虑到抽奖的峰值流量高，面对高并发抽奖请求和库存扣减，采用Redis decr分段消费和加锁兜底的设计，对于消费成功的库存，采用异步队列+定时任务更新库存，在不超卖的同时，减轻数据库压力并确保数据的最终一致性。
- 使用RabbitMQ消息实现发奖异步化，缩短用户的等待时间，利用定时任务周期性扫描库表，补偿未正确发送或消费失败的MQ消息，确保抽奖流程的完整性和准确性。

# 关键词

DDD架构、领域划分、设计模式、抽奖的计算、营销策略、差异化抽奖、库存扣减、异步化

# DDD架构

[DDD架构学习笔记](系统架构/领域驱动设计.md)

领域驱动设计 -》 领域（针对业务范围or问题域，明确业务核心问题） + 驱动（业务问题驱动领域建模、领域模型 驱动 代码实现） + 设计 （领域模型的设计，领域模型反应业务概念和业务规则）

DDD 是一种软件设计方法，软件设计方法涵盖了范式、模型、框架、方法论等内容，而 DDD 的很多规范约定，都是为了提高工程交付质量。如几个很重要的知识点；**框架分层结构、领域、实体、聚合、值对象、依赖倒置**等。它所有的手段，都希望以一个功能逻辑的实现为聚合，将功能所需的对象、接口、逻辑，按照领域划分到自己的领域内。

就像在这个项目中，我负责实现的**抽奖中的策略，就是一个独立的领域模型**。在这个领域中我需要提供策略的装载、随机数算法计算、抽奖模板调用（含责任链和规则树）功能，这样一个领域就像划分好的一个独立个体，它拥有属于它的对象信息（实体、值对象、聚合），当需要使用数据库资源、缓存资源，以及外部接口资源的时候，都通过**依赖倒置**进行调用。也就是说，我的领域不做其他模块的引入，而是领域只负责业务功能实现，所需的所有数据，则有外部接口通过依赖倒置提供

- 支撑域：和核心业务的实现密切相关的非业务功能，比如安全认证、用户管理、日志记录等

DDD设计的过程：

1. 建立统一语言：专家、业务
2. 分解问题域：限界上下文（领域模型）
3. 连接业务和系统

充血模型 和 贫血模型的区别

实体、值对象、聚合



首先列出流程：

1. 活动装配、把活动相关的 抽奖策略、抽奖奖品等信息预热
2. 点击签到、赠送积分， 操作积分账户
3. 免费赠送， 活动账户， 活动库存
4. 积分兑换， 扣减积分，操作积分账户，和 活动账户
5. 点击抽奖、创建抽奖单、判断是否有没有消费的抽奖单，如果没有，就执行抽奖策略
6. 抽奖策略：两阶段抽奖，责任链模式实现：黑名单抽奖、权重范围抽奖、默认抽奖，第二阶段自定义规则树实现抽奖n次解锁，以及库存判断，有兜底结果控制
7. 这里库存扣减、decr扣减， 延迟队列更新数据库，分段锁
8. 中奖结果，记录中奖流水以及写task任务， mq消费， 定时任务扫描有没有没有消费的消息。mq奖品发放

划分领域：

1、2345（活动）、67（抽奖策略）、8（抽奖结果）

# 怎么去迭代开发的

迭代开发的过程：

1. 策略设计那块的迭代开发，从最开始的串联，到模版+工厂 + 责任链开发，到规则树，其中考虑到一些多线程并发下的安全问题，还考虑到使用concurrenthashmap。
2. 一些方案的改进，比如一开始是这个方案，后来察觉到有漏洞，比如在分布式锁redis的设计那块，一开始独占锁，但是锁粒度太大，后来看到了concurrenthashmap的原理，想到减少锁粒度的方法，改为分段锁，大大提升并发度
3. 还有部分接口的设计，一开始设计的比较冗余，策略接口，一开始装配策略和策略抽奖调度 耦合，没有体现单一职责，这也是随着版本迭代，改进的。
4. 还有就是库表的设计的迭代，一开始想功能的时候，未必考虑的很全， 有些库表设计的不太合理，比如用户下单表块，最后采用了把活动、策略、次数等组合成一个sku的的方式来设计，提高了可扩展性

# 可能的问题

## 项目工程怎么搭建的？

类似于start.spring.io脚手架，我的项目统一使用maven-archetype-plugin插件，自定义了一套ddd工程脚手架。统一了版本标准和对应配套的开发环境，使用更容易

## 开发工具

 IntelliJ IDEA、WebStorm、Sequel Ace/Navicat、ApiPost、Docker、SwitchHosts、Termius（SSH）本地构建前后端镜像，PUSH 到 Docker Hub，再通过编写 docker compose 脚本，在云服务器部署。

## 哪些技术栈

springboot、mybatis、redis、mysql

## 前后端分离的接口跨域

配置@CrossOrigin

## 抽奖流程中，哪些被定义为值、哪些是实体

值对象通常用于描述对象属性的值，不具备唯一ID，不影响数据变化。如；数据库中字段的枚举值、业务流程中属性对象。如抽奖流程中，RuleLimitTypeVO 规则限定方式的枚举值对象、还有 RuleTreeVO 规则树值对象。

而那些实体对象，则具备唯一ID，会影响到最后的写库动作。如；抽奖发起实体、奖品信息实体对象。并且我们可以把一些和实体对象相关的功能**聚合**到对象内，这样的通用性会更好，避免所有调用方都需要自己编写逻辑。

## 依赖倒置是什么

DDD 中的依赖倒置是一个非常好的设计，尤其是与 MVC 结构对比的时候，MVC 的贫血模型结构设计，数据库持久化对象，很容易被当做业务对象使用，这样后期非常难维护。但在 DDD 的分层结构用，是以 domain 领域实现为核心，一个 domain 领域下所需的外部服务，都由领域层定义接口，让基础层做具体实现。而数据库持久化操作，定义的 PO 对象，就被这样的方式被限定在基础层了，外部是没法引入使用的，也就天然的防止了数据库持久化对象进入业务中。

## 为什么分为抽奖两个阶段

通过大量阅读源码、优秀的代码设计往往会对流程进行拆分、解耦，可扩展。比如spring中堆bean对象的拆解，所以，在设计抽奖模块时，对于需求中的各类功能点；黑名单抽奖、权重抽奖、默认抽奖、抽奖N次解锁、兜底抽奖等等情况，是可以拆解为抽奖前、后，2个行为动作的，基于这样的考虑后，就可以设计出非常容易扩展的松耦合结构。

## 为什么这两个阶段采用的点不一样？

在设计完抽奖前、中、后，搜耦合的结构模型后，对于抽奖前要执行哪种抽奖，但单向选择问题。所以这里使用了责任链模式，进行节点流程判断，从黑名单、权重，最后到默认，走一个单独的具体抽奖，所以使用责任链更为合适。

之后是进入抽奖的中和后，这两部的流程是相对复杂的，需要判断用户抽奖了几次，对于不同次会限定是否能获得某个奖品，同时还有库存的扣减，如果库存不足或者不满足n次抽奖得到某个奖品，则会进行兜底。那么这就是一个树规则的交叉流程，所以会使用了组合模式构建一颗规则树，并通过数据库表的动态配置决定在抽奖前完成后，后续的流程要如何进行。

## 抽中奖品库存扣减怎么做的？

关于库存的扣减，是一个非常重要的流程。尤其是这种单独资源竞争的场景，如果设计的不好，很容易把服务打挂。

所以在这套系统设计中，为了避免库存扣减直接更新库表的行级锁，而导致大量的用户进行等待状态。所以把数据库表的库存同步到 Redis 缓存中，在通过 incr 扣减的方式进行消费，同时为了确保在临界状态、库存恢复、异常处理等情况下不超卖，而对每一条产生从 incr 值，与抽奖的策略ID组合一个key，进行 setnx 加锁兜底，来保证不超卖。—— 这样的设计是颗粒度更小的锁方案设计，性能接近于无锁化。

## 同步库是怎么做的？

关于 redis 缓存和数据库表库存数据的流程，设计了异步更新，保持最终一致性的设计。在执行完库存的扣减操作后（在抽奖中规则树库存节点流程），发送一个扣减完成到 Redis 的异步队列（可以使用MQ+延迟消费），之后通过定时 Schedule Job 来消费队列。这样就可以控制效率速率，降低对数据库的压力。（因为我们不能 Redis 扣减的多快，就直接打到库表上，那样对数据库的压力依然很大，容易打挂）

## 支持不同场景的抽奖，库表怎么设计

领域模型的设计 ， 推动具体库表的设计

库表包括：

活动 -》 活动表、抽奖次数表

策略领域推动 -》策略表、策略明细表（库存、概率、规则key）、规则表、规则树

奖品领域推动 -〉奖品表

任务领域推动-》任务表

积分领域 -〉返利相关、积分表等

## 什么问题难住的时间最长，为什么

可以对大营销抽奖模型流程的设计和库表设计，最为耗时，因为你不断的在思考如何拆解出一个好扩展的松耦合结构，同时拆解后，还要保证搜耦合下的高内聚。所以这部分是比较耗时的。同时也可以说在设定某个方法的，名称、入参、出参时，做了大量的思考。因为名字的定义非常影响以后的理解。好的代码就是文档，所以对于这样的东西花费不少时间。

## 抽奖奖品库存如何处理，怎么保证最终一致性？

在抽奖秒杀这样的场景下，都需要把库存缓存到 Redis 中进行使用。而不能数据库表加行级锁，否则大量的秒杀进行通过加锁和等待释放，就会夯住数据库链接直至拖垮整个服务。

那么使用缓存通过大营销项目中的颗粒度更低的分段锁后，怎么来保证一致性呢。这里需要3个步骤，首先是每次扣减完库存，都会写入到 Redis 延迟队列 / MQ 延迟消息，缓慢更新数据库库存。之后是 Redis 内的预热库存消耗完毕后，发送最终 MQ 消息，更新数据库的剩余库存为 0，最终活动结束后，还有任务补偿，扫描抽奖所产生的的参与记录单，更新最终的库存消耗。这里就可以用订单 MQ 通过 Flink 计算，更新最终库存也是可以的。

## 写入中奖记录，发送MQ消息失败如何处理？

本身发送MQ是可能存在万分之一或者十万分之的失败的，而数据库操作和MQ操作，本身不能做数据库事务。但又要保证失败后的补偿处理。所以要结合中奖记录在写一条发送MQ的任务记录，任务记录上有一个状态，标记是否发送完成，这样就可以通过任务扫描的方式完成 MQ 的补偿发送。

但这里要知道，做完本身的中奖记录和任务记录后写库事务后，要顺序的可以是多线程的方式，完成一次MQ发送，并且更新数据库 Task 记录。这里是为了业务流程最快的推进，如果是更新失败也没关系，还有兜底的任务补偿。【任务补偿的数量并不多，但非常需要这个手段】

## 生产者可能多次发送同一个MQ，怎么保证奖品不会超发？

这是一个幂等的设计处理，MQ 的消息是必须含**带具有唯一标识的业务ID的**。比如订单ID、奖品ID、支付单ID、交易单ID、贷款单ID等等。接收MQ的系统，通过唯一ID业务，更新或者写库的时候可以保证幂等性。这样也就不会产生超发的可能。（全局唯一的id，雪花算法，考虑了时间戳 + 计算机的id + 序列号）

- 其他保证幂等的设计
  - select + insert. + 主键 / 唯一索引冲突
  - 直接insert捕获异常
  - 流水表的状态，状态机幂等
  - 锁：悲观（for update） 乐观 version
  - 全局token

## 抽奖算法如何提供O(1)时间复杂度，提高抽奖效率？

在大营销系统中，运营人员配置好抽奖活动后，开始上线对外后，会进行数据的预热数据。这个预热的过程会把活动信息、策略信息、库存信息都存储到 Redis 里进行使用。

而抽奖的策略就是记录了一个策略下N个奖品的概率，将概率转换为对应的整数数量，写入到缓存中。那么在抽奖的时候就按照整数数量生成随机数来抽奖。这样用空间换时间的效率是非常高的。

## 消费MQ的过程中，如果使用多线程会遇到什么问题？

这是一个非常容易产生事故的问题，本身 MQ 消费就是多个应用分别消费，如果有消费失败的，可以抛异常重试。但如果是一个消费 MQ 的应用，里面写了多线程，就可能会出现大量的 MQ 挤压，消费不过来，导致系统瘫痪。而如果你重启，那么这些拉下来的 MQ 消息也就随时丢失了。

## 少卖和超卖

超卖不会出现，有个保证的点，一个是incr 值的限制，另外一个是对每个key加锁的兜底设计。确保了不会超卖。少卖是有可能的，核心原因是因为 incr 操作和数据操作不是是一个事务，有可能库存扣减完了，但最终操作库失败了。那么这个库存就丢失了，可能会少卖。但一般并不会对少卖做过多的流程，如果想管理，也可以把少卖的库存异常，加入单独的 redis 队列来重新消费就可以了

分布式锁流程：

- 获取抽奖活动库存 Key
- 扣减库存，目前占用库存数
- 超出库存判断，进行恢复原始库存
- 以活动库存占用编号，生成对应加锁Key，细化锁的颗粒度
- 使用 Redis.setNx 加一个分布式锁
- 删除分布式锁 Key

活动领取完成后，其实这个时候只是把缓存的库存扣掉了，但数据库中的库存并没有扣减，所以我们需要发送一个 MQ 消息，来对数据库中的库存进行处理。因为 MQ 可以消峰因此在降低 MQ 分片的情况下，消费效率有所下降，并不会对数据库造成压力，保证最终数据一致性即可。但也有例外，所以我们提到可以使用定时任务来更新数据库库存。

## 对于数据库和redis的一致性怎么解决

- 第1个手段；每次消费incr值，写入延迟队列，趋势更新数据库数据。最终一致。
- 第2个手段；incr 库存值消耗为0时，发送mq消息，更新最终库存量。（可能不准，比如incr值消耗中，少卖的情况）
- 第3个手段；活动到期后，任务扫描活动产生订单量，校准库存。

## 什么情况下使用DDD架构，什么情况下使用mvc架构？

DDD 是软件设计方法，对复杂的项目更为合适。但这里要清楚，DDD 如果只的是设计方法中的建模工程结构，和 MVC 对比的话。DDD 的结构更为先进，即使不使用 DDD 的软件设计方法，只遵循这套结构，都是可以编写出非常好的代码的。MVC 的约束相对较低，个人开发还好，如果多人协作，会出现腐化严重的问题

## 大营销抽奖项目被问到抽奖项目按道理应该不是一个高并发的过程

1. 春晚红包是不是抽奖，拼多多一进页面就有各种【转转转】来获得一个券，支付完成又一个转转转。直接领券远没有抽奖来的刺激，即使是发券，也是用抽奖方式更多。
2. 每秒的请求量如果超过1000tps，打到库上资源竞争，都会出现大量的数据库连接等待。一般一个应用分配的数据库连接池也就那么20来个。如果都打到库上，都能把库打挂。
3. 面试这么问，大部分是为了通过一个质疑的场景，来看是否有思考过。而不是面试问什么就是什么，反而是问什么就不是什么，但不是什么，要拿出举证理由。



# 线程池用了吗

定时任务扫描数据库表 ，发送消息的时候， 用到了线程池

# 流程梳理

需求分析：抽奖、奖品发放、