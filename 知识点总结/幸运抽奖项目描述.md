# 简历上的写法

该系统采用DDD架构设计，划分为**抽奖活动、抽奖策略、奖品、积分、返利**等领域。代码开发运用多种设计模式，支持多种营销策略，如：用户积分兑换抽奖次数、积分返利等，实现差异化抽奖流程，如：通用抽奖、黑名单、抽奖N次解锁奖品范围、消耗积分解锁奖品等各类玩法，并对抽奖的计算和秒杀做了设计优化。

- 根据不同的抽奖玩法，将抽奖流程抽象为**抽奖前后两阶段抽奖**。运用模版模式、工厂模式定义通用抽奖流程，抽奖前采用责任链完成黑名单、奖品权重过滤，采用自定义规则树对抽奖后的动作的次数和库存信息进行动态处理，实现差异化抽奖。
- 考虑到抽奖的峰值流量高，面对高并发抽奖请求和库存扣减，采用Redis decr分段消费和加锁兜底的设计，对于消费成功的库存，采用异步队列+定时任务更新库存，在不超卖的同时，减轻数据库压力并确保数据的最终一致性。
- 使用RabbitMQ消息实现发奖异步化，缩短用户的等待时间，利用定时任务周期性扫描库表，补偿未正确发送或消费失败的MQ消息，确保抽奖流程的完整性和准确性。

# 关键词

DDD架构、领域划分、设计模式、抽奖的计算、营销策略、差异化抽奖、库存扣减、异步化



# DDD架构

[DDD架构学习笔记](系统架构/领域驱动设计.md)

领域驱动设计 -》 领域（针对业务范围or问题域，明确业务核心问题） + 驱动（业务问题驱动领域建模、领域模型 驱动 代码实现） + 设计 （领域模型的设计，领域模型反应业务概念和业务规则）

DDD 是一种软件设计方法，软件设计方法涵盖了范式、模型、框架、方法论等内容，而 DDD 的很多规范约定，都是为了提高工程交付质量。如几个很重要的知识点；**框架分层结构、领域、实体、聚合、值对象、依赖倒置**等。它所有的手段，都希望以一个功能逻辑的实现为聚合，将功能所需的对象、接口、逻辑，按照领域划分到自己的领域内。

就像在这个项目中，我负责实现的**抽奖中的策略，就是一个独立的领域模型**。在这个领域中我需要提供策略的装载、随机数算法计算、抽奖模板调用（含责任链和规则树）功能，这样一个领域就像划分好的一个独立个体，它拥有属于它的对象信息（实体、值对象、聚合），当需要使用数据库资源、缓存资源，以及外部接口资源的时候，都通过**依赖倒置**进行调用。也就是说，我的领域不做其他模块的引入，而是领域只负责业务功能实现，所需的所有数据，则有外部接口通过依赖倒置提供

- 支撑域：和核心业务的实现密切相关的非业务功能，比如安全认证、用户管理、日志记录等

DDD设计的过程：

1. 建立统一语言：专家、业务
2. 分解问题域：限界上下文（领域模型）
3. 连接业务和系统

充血模型 和 贫血模型的区别

实体、值对象、聚合



首先列出流程：

1. 活动装配、把活动相关的 抽奖策略、抽奖奖品等信息预热
2. 点击签到、赠送积分， 操作积分账户
3. 免费赠送， 活动账户， 活动库存
4. 积分兑换， 扣减积分，操作积分账户，和 活动账户
5. 点击抽奖、创建抽奖单、判断是否有没有消费的抽奖单，如果没有，就执行抽奖策略
6. 抽奖策略：两阶段抽奖，责任链模式实现：黑名单抽奖、权重范围抽奖、默认抽奖，第二阶段自定义规则树实现抽奖n次解锁，以及库存判断，有兜底结果控制
7. 这里库存扣减、decr扣减， 延迟队列更新数据库，分段锁
8. 中奖结果，记录中奖流水以及写task任务， mq消费， 定时任务扫描有没有没有消费的消息。mq奖品发放

划分领域：

1、2345（活动）、67（抽奖策略）、8（抽奖结果）

# 怎么去迭代开发的

迭代开发的过程：

1. 策略设计那块的迭代开发，从最开始的串联，到模版+工厂 + 责任链开发，到规则树，其中考虑到一些多线程并发下的安全问题，还考虑到使用concurrenthashmap。
2. 一些方案的改进，比如一开始是这个方案，后来察觉到有漏洞，比如在分布式锁redis的设计那块，一开始独占锁，但是锁粒度太大，后来看到了concurrenthashmap的原理，想到减少锁粒度的方法，改为分段锁，大大提升并发度
3. 还有部分接口的设计，一开始设计的比较冗余，策略接口，一开始装配策略和策略抽奖调度 耦合，没有体现单一职责，这也是随着版本迭代，改进的。
4. 还有就是库表的设计的迭代，一开始想功能的时候，未必考虑的很全， 有些库表设计的不太合理，比如用户下单表块，最后采用了把活动、策略、次数等组合成一个sku的的方式来设计，提高了可扩展性

# 可能的问题

## 项目工程怎么搭建的？

类似于start.spring.io脚手架，我的项目统一使用maven-archetype-plugin插件，自定义了一套ddd工程脚手架。统一了版本标准和对应配套的开发环境，使用更容易

## 开发工具

 IntelliJ IDEA、WebStorm、Sequel Ace/Navicat、ApiPost、Docker、SwitchHosts、Termius（SSH）本地构建前后端镜像，PUSH 到 Docker Hub，再通过编写 docker compose 脚本，在云服务器部署。

## 哪些技术栈

springboot、mybatis、redis、mysql

## 前后端分离的接口跨域

配置@CrossOrigin

## 抽奖流程中，哪些被定义为值、哪些是实体

值对象通常用于描述对象属性的值，不具备唯一ID，不影响数据变化。如；数据库中字段的枚举值、业务流程中属性对象。如抽奖流程中，RuleLimitTypeVO 规则限定方式的枚举值对象、还有 RuleTreeVO 规则树值对象。

而那些实体对象，则具备唯一ID，会影响到最后的写库动作。如；抽奖发起实体、奖品信息实体对象。并且我们可以把一些和实体对象相关的功能**聚合**到对象内，这样的通用性会更好，避免所有调用方都需要自己编写逻辑。

## 依赖倒置是什么

DDD 中的依赖倒置是一个非常好的设计，尤其是与 MVC 结构对比的时候，MVC 的贫血模型结构设计，数据库持久化对象，很容易被当做业务对象使用，这样后期非常难维护。但在 DDD 的分层结构用，是以 domain 领域实现为核心，一个 domain 领域下所需的外部服务，都由领域层定义接口，让基础层做具体实现。而数据库持久化操作，定义的 PO 对象，就被这样的方式被限定在基础层了，外部是没法引入使用的，也就天然的防止了数据库持久化对象进入业务中。

## 为什么分为抽奖两个阶段

通过大量阅读源码、优秀的代码设计往往会对流程进行拆分、解耦，可扩展。比如spring中堆bean对象的拆解，所以，在设计抽奖模块时，对于需求中的各类功能点；黑名单抽奖、权重抽奖、默认抽奖、抽奖N次解锁、兜底抽奖等等情况，是可以拆解为抽奖前、后，2个行为动作的，基于这样的考虑后，就可以设计出非常容易扩展的松耦合结构。

## 为什么这两个阶段采用的点不一样？

在设计完抽奖前、中、后，搜耦合的结构模型后，对于抽奖前要执行哪种抽奖，但单向选择问题。所以这里使用了责任链模式，进行节点流程判断，从黑名单、权重，最后到默认，走一个单独的具体抽奖，所以使用责任链更为合适。

之后是进入抽奖的中和后，这两部的流程是相对复杂的，需要判断用户抽奖了几次，对于不同次会限定是否能获得某个奖品，同时还有库存的扣减，如果库存不足或者不满足n次抽奖得到某个奖品，则会进行兜底。那么这就是一个树规则的交叉流程，所以会使用了组合模式构建一颗规则树，并通过数据库表的动态配置决定在抽奖前完成后，后续的流程要如何进行。

## 抽中奖品库存扣减怎么做的？

关于库存的扣减，是一个非常重要的流程。尤其是这种单独资源竞争的场景，如果设计的不好，很容易把服务打挂。

所以在这套系统设计中，为了避免库存扣减直接更新库表的行级锁，而导致大量的用户进行等待状态。所以把数据库表的库存同步到 Redis 缓存中，在通过 incr 扣减的方式进行消费，同时为了确保在临界状态、库存恢复、异常处理等情况下不超卖，而对每一条产生从 incr 值，与抽奖的策略ID组合一个key，进行 setnx 加锁兜底，来保证不超卖。—— 这样的设计是颗粒度更小的锁方案设计，性能接近于无锁化。

## 同步库是怎么做的？

关于 redis 缓存和数据库表库存数据的流程，设计了异步更新，保持最终一致性的设计。在执行完库存的扣减操作后（在抽奖中规则树库存节点流程），发送一个扣减完成到 Redis 的异步队列（可以使用MQ+延迟消费），之后通过定时 Schedule Job 来消费队列。这样就可以控制效率速率，降低对数据库的压力。（因为我们不能 Redis 扣减的多快，就直接打到库表上，那样对数据库的压力依然很大，容易打挂）

## 支持不同场景的抽奖，库表怎么设计

领域模型的设计 ， 推动具体库表的设计

库表包括：

活动 -》 活动表、抽奖次数表

策略领域推动 -》策略表、策略明细表（库存、概率、规则key）、规则表、规则树

奖品领域推动 -〉奖品表

任务领域推动-》任务表

积分领域 -〉返利相关、积分表等

## 什么问题难住的时间最长，为什么

可以对大营销抽奖模型流程的设计和库表设计，最为耗时，因为你不断的在思考如何拆解出一个好扩展的松耦合结构，同时拆解后，还要保证搜耦合下的高内聚。所以这部分是比较耗时的。同时也可以说在设定某个方法的，名称、入参、出参时，做了大量的思考。因为名字的定义非常影响以后的理解。好的代码就是文档，所以对于这样的东西花费不少时间。

## 抽奖奖品库存如何处理，怎么保证最终一致性？

在抽奖秒杀这样的场景下，都需要把库存缓存到 Redis 中进行使用。而不能数据库表加行级锁，否则大量的秒杀进行通过加锁和等待释放，就会夯住数据库链接直至拖垮整个服务。

那么使用缓存通过大营销项目中的颗粒度更低的分段锁后，怎么来保证一致性呢。这里需要3个步骤，首先是每次扣减完库存，都会写入到 Redis 延迟队列 / MQ 延迟消息，缓慢更新数据库库存。之后是 Redis 内的预热库存消耗完毕后，发送最终 MQ 消息，更新数据库的剩余库存为 0，最终活动结束后，还有任务补偿，扫描抽奖所产生的的参与记录单，更新最终的库存消耗。这里就可以用订单 MQ 通过 Flink 计算，更新最终库存也是可以的。

## 写入中奖记录，发送MQ消息失败如何处理？

本身发送MQ是可能存在万分之一或者十万分之的失败的，而数据库操作和MQ操作，本身不能做数据库事务。但又要保证失败后的补偿处理。所以要结合中奖记录在写一条发送MQ的任务记录，任务记录上有一个状态，标记是否发送完成，这样就可以通过任务扫描的方式完成 MQ 的补偿发送。

但这里要知道，做完本身的中奖记录和任务记录后写库事务后，要顺序的可以是多线程的方式，完成一次MQ发送，并且更新数据库 Task 记录。这里是为了业务流程最快的推进，如果是更新失败也没关系，还有兜底的任务补偿。【任务补偿的数量并不多，但非常需要这个手段】

## 生产者可能多次发送同一个MQ，怎么保证奖品不会超发？

这是一个幂等的设计处理，MQ 的消息是必须含**带具有唯一标识的业务ID的**。比如订单ID、奖品ID、支付单ID、交易单ID、贷款单ID等等。接收MQ的系统，通过唯一ID业务，更新或者写库的时候可以保证幂等性。这样也就不会产生超发的可能。（全局唯一的id，雪花算法，考虑了时间戳 + 计算机的id + 序列号）

- 其他保证幂等的设计
  - select + insert. + 主键 / 唯一索引冲突
  - 直接insert捕获异常
  - 流水表的状态，状态机幂等
  - 锁：悲观（for update） 乐观 version
  - 全局token

## 抽奖算法如何提供O(1)时间复杂度，提高抽奖效率？

在大营销系统中，运营人员配置好抽奖活动后，开始上线对外后，会进行数据的预热数据。这个预热的过程会把活动信息、策略信息、库存信息都存储到 Redis 里进行使用。

而抽奖的策略就是记录了一个策略下N个奖品的概率，将概率转换为对应的整数数量，写入到缓存中。那么在抽奖的时候就按照整数数量生成随机数来抽奖。这样用空间换时间的效率是非常高的。

## 消费MQ的过程中，如果使用多线程会遇到什么问题？

这是一个非常容易产生事故的问题，本身 MQ 消费就是多个应用分别消费，如果有消费失败的，可以抛异常重试。但如果是一个消费 MQ 的应用，里面写了多线程，就可能会出现大量的 MQ 挤压，消费不过来，导致系统瘫痪。而如果你重启，那么这些拉下来的 MQ 消息也就随时丢失了。

## 少卖和超卖

超卖不会出现，有个保证的点，一个是incr 值的限制，另外一个是对每个key加锁的兜底设计。确保了不会超卖。少卖是有可能的，核心原因是因为 incr 操作和数据操作不是是一个事务，有可能库存扣减完了，但最终操作库失败了。那么这个库存就丢失了，可能会少卖。但一般并不会对少卖做过多的流程，如果想管理，也可以把少卖的库存异常，加入单独的 redis 队列来重新消费就可以了

分布式锁流程：

- 获取抽奖活动库存 Key
- 扣减库存，目前占用库存数
- 超出库存判断，进行恢复原始库存
- 以活动库存占用编号，生成对应加锁Key，细化锁的颗粒度
- 使用 Redis.setNx 加一个分布式锁
- 删除分布式锁 Key

活动领取完成后，其实这个时候只是把缓存的库存扣掉了，但数据库中的库存并没有扣减，所以我们需要发送一个 MQ 消息，来对数据库中的库存进行处理。因为 MQ 可以消峰因此在降低 MQ 分片的情况下，消费效率有所下降，并不会对数据库造成压力，保证最终数据一致性即可。但也有例外，所以我们提到可以使用定时任务来更新数据库库存。

## 对于数据库和redis的一致性怎么解决

- 第1个手段；每次消费incr值，写入延迟队列，趋势更新数据库数据。最终一致。
- 第2个手段；incr 库存值消耗为0时，发送mq消息，更新最终库存量。（可能不准，比如incr值消耗中，少卖的情况）
- 第3个手段；活动到期后，任务扫描活动产生订单量，校准库存。

## 什么情况下使用DDD架构，什么情况下使用mvc架构？

DDD 是软件设计方法，对复杂的项目更为合适。但这里要清楚，DDD 如果只的是设计方法中的建模工程结构，和 MVC 对比的话。DDD 的结构更为先进，即使不使用 DDD 的软件设计方法，只遵循这套结构，都是可以编写出非常好的代码的。MVC 的约束相对较低，个人开发还好，如果多人协作，会出现腐化严重的问题

## 大营销抽奖项目被问到抽奖项目按道理应该不是一个高并发的过程

1. 春晚红包是不是抽奖，拼多多一进页面就有各种【转转转】来获得一个券，支付完成又一个转转转。直接领券远没有抽奖来的刺激，即使是发券，也是用抽奖方式更多。
2. 每秒的请求量如果超过1000tps，打到库上资源竞争，都会出现大量的数据库连接等待。一般一个应用分配的数据库连接池也就那么20来个。如果都打到库上，都能把库打挂。
3. 面试这么问，大部分是为了通过一个质疑的场景，来看是否有思考过。而不是面试问什么就是什么，反而是问什么就不是什么，但不是什么，要拿出举证理由。



# 线程池用了吗

定时任务扫描数据库表 ，发送消息的时候， 用到了线程池

# 流程梳理

需求分析：抽奖、奖品发放、



两端：C端面向用户的活动页，B端创建活动的后台

B端 创建活动，配置活动相关信息（奖品），C端渲染， 用户抽奖

奖品类型：实物、虚拟商品（权益、优惠券、现金、积分），不同的奖品类型履约方式不同

- 实物：物流履约，设计上要考虑，发货流程，单号信息，回传和通知
- 虚拟商品：系统触发，考虑和履约系统的交互，触发履约的时间点，以及下发履约后的信息通知
- 现金：不同面额的现金可以看作一个单独的奖品（直接放现金比较敏感，需要联动内部付款系统指定现金发放）

奖品概率

- 技术实现上，用到了随机数算法，需要概率加起来满足100%，有限制（优化点）

抽奖活动：围绕抽奖的一个配置，主要的信息：活动名称、奖品名称、奖品库存、每个活动都有一个唯一的标识

抽奖机会可以通过积分兑换的方式获取

抽奖门槛：连续签到 or 积分兑换抽奖机会等， 比较简单就是当前登陆就可以获得抽奖机会





1. **DDD架构的具体应用**：在您的项目中，DDD是如何被具体实施的？您是如何划分界限上下文（Bounded Contexts）和聚合（Aggregates）的？
2. **领域模型的设计**：请详细描述一下抽奖活动、抽奖策略、奖品等核心领域模型的设计思路。
3. **设计模式的应用**：除了模版模式和工厂模式，您还使用了哪些设计模式来优化代码结构和提升系统灵活性？请举例说明。
4. **两阶段抽奖流程的设计动机**：为什么选择将抽奖流程抽象为两阶段？这样做带来了哪些好处？
5. **责任链模式的实现细节**：在第一阶段使用责任链处理黑名单和权重过滤时，责任链的具体实现细节是怎样的？如何保证链中的每个节点都能高效执行？
6. **自定义规则树的实现**：请详细介绍自定义规则树是如何设计和实现的，它如何支持动态判断抽奖动作和库存信息？
7. **高并发下的库存扣减策略**：您提到使用分段竞态锁来优化库存扣减，具体是如何实现的？相比独占锁，它的优势在哪里？
8. **异步队列与定时任务的选择**：为什么选择RabbitMQ作为异步队列，以及Spring Task来处理定时任务？这些选择是如何满足项目需求的？
9. **数据一致性的保障**：在异步处理库存更新时，您是如何保证数据最终一致性的？有没有遇到过数据不一致的情况，又是如何解决的？
10. **MQ消息补偿机制**：请详细描述MQ消息补偿机制的工作原理和实现细节，它是如何确保消息被正确消费的？
11. **系统监控与日志**：项目中是如何进行性能监控和日志管理的？有没有使用特定的工具或框架？
12. **异常处理与容错机制**：在开发过程中，您是如何设计异常处理和容错机制的？能否举例说明？
13. **代码质量与测试**：项目中采取了哪些措施来保证代码质量？单元测试、集成测试的覆盖率如何？
14. **技术选型考量**：在选择SpringBoot、MySQL、Redis等技术栈时，有哪些具体的考量因素？
15. **性能优化经验**：除了上述提到的库存扣减和异步处理，您还采取了哪些性能优化措施？
16. **团队协作与项目管理**：在开发过程中，团队是如何协作的？使用了哪些项目管理工具和敏捷实践？
17. **技术挑战与解决方案**：在项目实施过程中，遇到了哪些技术挑战？您是如何带领团队克服这些挑战的？
18. **系统扩展性考虑**：随着业务量的增长，系统如何保持其扩展性？有哪些前瞻性的设计考虑？
19. **安全性设计**：项目中是否有考虑到安全性设计，比如防止作弊、数据加密等方面？
20. **未来规划**：对于该项目的未来，您有哪些改进或扩展的计划？如何持续优化用户体验和提升系统性能？
21. **数据迁移与升级**：在项目运行过程中，如果需要进行数据库迁移或系统升级，您会采取哪些策略和步骤来确保数据的完整性和系统的平稳过渡？
22. **用户行为分析**：为了优化抽奖体验和营销策略，您是否考虑或实施了用户行为分析？如果实施了，具体是如何收集和分析数据的？
23. **分布式事务处理**：在涉及到多个服务或数据库操作的复杂业务场景中，您是如何处理分布式事务的？是否采用了SAGA、TCC等模式？
24. **服务降级与熔断**：面对可能的服务过载或依赖服务故障，您的系统中是否集成了服务降级和熔断机制？如何设计和实施这些机制？
25. **微服务划分**：虽然您提到了DDD架构，但如果您将系统进一步微服务化，您会如何划分服务边界？基于哪些原则？
26. **配置管理与动态更新**：系统中是否采用了配置管理服务（如Spring Cloud Config、Apollo等）？如何管理和动态更新配置文件？
27. **CI/CD流程**：您的项目是否实现了持续集成/持续部署（CI/CD）？具体使用了哪些工具和流程？
28. **容器化部署**：考虑到容器化技术在现代应用部署中的普及，您的项目是否支持Docker或Kubernetes等容器化技术？
29. **安全漏洞扫描与修复**：在维护项目过程中，您如何确保及时发现并修复安全漏洞？是否采用了自动化的安全扫描工具？
30. **缓存策略**：在您的项目中，Redis主要用于哪些缓存场景？您是如何设计缓存策略的，以避免缓存击穿、雪崩等问题？
31. **A/B测试**：为了验证新的营销策略或功能的有效性，您是否实施了A/B测试？具体是如何进行试验设计和数据分析的？
32. **数据库索引优化**：针对MySQL数据库，您是如何优化查询性能的？特别是针对高并发的抽奖和库存查询场景。
33. **服务监控与告警**：系统中是否集成了服务监控和告警系统？如何实时跟踪系统健康状况并及时响应异常情况？
34. **数据库水平拆分**：随着数据量的增长，您是否考虑过对数据库进行水平拆分？如果有，具体的拆分策略和步骤是什么？
35. **灰度发布**：为了降低新功能上线风险，您是否采用了灰度发布策略？具体是如何实现的？
36. **用户反馈与迭代**：在项目开发和运营过程中，您是如何收集用户反馈并根据反馈进行迭代优化的？
37. **跨域与CORS**：在处理前后端分离的场景时，您是如何处理跨域资源共享（CORS）问题的？
38. **性能压测**：在项目上线前，您是否进行了全面的性能压测？使用了哪些工具和方法来模拟高并发场景？
39. **API设计与文档**：您如何设计RESTful API以保持良好的接口规范和易于使用？是否使用了Swagger等工具来自动生成和维护API文档？
40. **代码审查与质量保证**：在您的团队中，代码审查是如何进行的？是否有特定的流程和工具来确保代码质量和风格的一致性？
41. **API安全性**：在设计和实现API时，您采取了哪些安全措施来保护数据免受未授权访问和恶意攻击？
42. **故障转移与容灾**：在面对服务故障或数据中心问题时，您的系统是否具备故障转移和容灾能力？具体是如何实现的？
43. **微服务的通信与治理**：在微服务架构中，服务间的通信通常使用什么协议和框架？您是如何进行服务治理的，包括服务发现、负载均衡、限流熔断等？
44. **性能瓶颈识别与优化**：在项目开发过程中，您是如何识别和解决性能瓶颈的？是否有具体的案例可以分享？
45. **代码重构经验**：随着项目的不断发展，您是否进行过代码重构？如果有，请谈谈重构的动机、过程和效果。
46. **单元测试与覆盖率**：您是如何确保单元测试的覆盖率和有效性的？是否采用了测试驱动开发（TDD）的方法？
47. **日志级别与策略**：在项目中，您是如何设置日志级别的？是否根据不同的环境（如开发、测试、生产）制定了不同的日志策略？
48. **代码质量工具**：您使用了哪些代码质量工具来辅助开发，如静态代码分析工具、代码格式化工具等？这些工具如何帮助提升代码质量？
49. **数据库事务隔离级别**：在MySQL数据库中，您是如何根据业务需求设置事务隔离级别的？不同的隔离级别对系统性能和一致性有何影响？
50. **未来技术探索**：在技术日新月异的今天，您是否关注并尝试将新技术应用到项目中？比如Serverless、云原生、AI等。如果有，请分享一些您的想法或实践经验。



### 功能角度

1. **功能模块化**：在项目中，您是如何将不同功能模块化的？这样做的好处是什么？有没有遇到模块间耦合度过高的挑战，您是如何解决的？
2. **抽奖算法设计**：请详细介绍一下您设计的抽奖算法，它是如何保证公平性和随机性的？在算法中，您是如何处理奖品概率分配和权重调整的？
3. **用户体验优化**：为了提高用户参与度和满意度，您在项目中采取了哪些用户体验优化措施？比如界面设计、交互流程、错误处理等方面。
4. **营销策略整合**：项目中支持的多种营销策略（如积分兑换、积分返利）是如何整合到抽奖系统中的？这些策略之间是否存在优先级或互斥关系？
5. **国际化与本地化**：如果您的项目需要支持多语言或多地区用户，您是如何处理国际化与本地化问题的？包括日期、时间、货币格式等方面。

### 技术栈角度

1. **SpringBoot应用优化**：在SpringBoot项目中，您采取了哪些措施来优化应用启动速度、内存占用和性能？
2. **MyBatis与数据库交互**：在MyBatis中，您是如何管理SQL语句的？是否使用了XML映射文件或注解方式？如何避免SQL注入等安全问题？
3. **Redis缓存策略**：在项目中，Redis不仅用于缓存，还可能用于其他场景（如分布式锁、消息队列等）。请谈谈您在Redis使用上的策略和最佳实践。
4. **RabbitMQ消息队列**：在使用RabbitMQ时，您是如何设计消息队列的？如何确保消息的顺序性、可靠性和持久性？
5. **Spring Task定时任务**：在项目中，Spring Task是如何被用于实现定时任务的？您是如何管理定时任务的调度和执行的？是否遇到过并发执行或资源竞争的问题？

### 数据库角度

1. **数据库设计原则**：在数据库设计时，您遵循了哪些基本原则（如规范化、反规范化、索引优化等）？这些原则是如何在项目中应用的？
2. **事务管理**：在MySQL数据库中，您是如何管理事务的？是否采用了显式事务控制？在分布式系统中，您是如何处理跨数据库事务的？
3. **数据库性能调优**：为了提高数据库查询性能，您采取了哪些调优措施？比如查询优化、索引调整、分区表等。
4. **数据备份与恢复**：项目中是否制定了数据备份与恢复策略？您是如何确保数据的安全性和可恢复性的？
5. **数据库迁移与升级**：如果项目需要迁移到新的数据库环境或进行数据库版本升级，您会采取哪些步骤和注意事项？