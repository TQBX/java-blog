# 设计模式

## 单例模式

### 双重检查锁

用双重检查锁的方式实现单例模式：

```java
public class Singleton {
	//注意使用volatile防止指令重排序
    private volatile static Singleton instance;
	//私有化构造方法，单例模式基本操作
    private Singleton() {
    }
	//静态获取单例的方法
    public  static Singleton getInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (instance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

使用`volatile`的原因：防止指令重排序。

> `instance= new Singleton();`这一步，是一个实例化的过程，底层其实分为三部执行：
>
> 1. 为instance分配内存空间：`memory = allocate();`
> 2. 实例化instance。`ctorInstance(memory);`
> 3. 将instance指向分配的内存地址。`instance = memory;`

由于JVM具有指令重排序的特性，指令的执行顺序可能会变成1，3，2。在多线程环境下，可能某个线程可能会得到未初始化的实例。

举个例子：加入线程A执行了1和2之后，线程B调用getInstance的时候，会发现instance不为null，会直接返回这个没有执行过指令3的实例。

### 静态内部类

```java
public class Singleton {
    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }

    /**
     * 静态内部类
     */
    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }
}
```

第一次加载Singleton类时不会初始化实例，只有在第一次调用getInstance方法时，虚拟机才会加载holder。

既保证线程安全，也保证单例对象唯一，也实现延迟初始化。

### 枚举单例

double check和静态内部类的写法都不错，但是都不能防止被反序劣化生成多个实例。

但枚举单例可以！

```java
public enum SingletonEnum {
    INSTANCE;
}
```

默认枚举实例的创建是线程安全的，即使**反序列化**也不会生成新的实例，**任何情况下都是一个单例**。

# 算法

## 快排、归并

归并

```java
    private void merge(int[] q, int l, int r) {
        if(l >= r) return;
        int mid = l + r >> 1;
        merge(q, l, mid);
        merge(q, mid + 1, r);
        int[] tmp = new int[r - l + 1];

        int k = 0, i = l, j = mid + 1;
        while(i <= mid && j <= r)
            if(q[i] <= q[j]) tmp[k++] = q[i++];
            else tmp[k++] = q[j++];

        while(i <= mid) tmp[k++] = q[i++];
        while(j <= r) tmp[k++] = q[j++];

        for(i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
    }
```

快排

```java
    void quickSort(int[] q, int l, int r) {
        if(l >= r) return;
        int i = l - 1, j = r + 1, x = q[l + r >> 1];
        while(i < j) {
            do i++; while(q[i] < x);
            do j--; while(q[j] > x);
            if(i < j) swap(q, i, j);
        }
        quickSort(q, l, j);
        quickSort(q, j + 1, r);

    }
```



```java
    int p(int[] x, int l, int r) {
        int i = l, j = r, t = x[l];
        while(i < j) {
            while(i < j && x[j] >= t) {
                j --;
            }
            if(i < j) {
                x[i] = x[j];
                i ++;
            }
            while(i < j && x[i] < t) {
                i ++;
            }
            if(i < j) {
                x[j] = x[i];
                j --;
            }
        }
        x[i] = t;
        return i;
    }
    void qs(int[] x, int l, int r) {
        if(l >= r) return;
        int pivot = p(x, l, r);
        qs(x, l, pivot - 1);
        qs(x, pivot + 1, r);
    }
```

LC3无重复字符的最长子串

LC93 复原IP地址

LC415 字符串相加（大数相加，记得进位1）

LCR181 字符串中的单词反转

LC15 三数之和

LC39组合综合

LC40组合总和2

LC215 数组中的第k个最大元素

LC704 二分查找

LC121 买卖股票的最佳时机

LC53 最大子数组和

LC20 有效的括号

LCR090打家劫舍2

LC165比较版本号

LC189 轮转数组

LC124 二叉树中的最大路径和

```java
```



LC82 删除排序链表中的重复元素2

LC5最长回文子串

LC146 LRU机制

LC1120 子数的最大平均值

LC509 斐波那契数



## 非递归中序遍历

思路：左子树一直往左走，入栈，直到走到null。 退回一步，入答案，往右子树走一步

```java
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stk = new Stack<>();
        while(root != null || !stk.isEmpty()) {
            if(root != null) {
                stk.push(root);
                root = root.left;
            } else {
                root = stk.pop();
                res.add(root.val);
                root = root.right;
            }
        }
        return res;
    }
```

## python写法

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        # 选择[l, r] 的树，返回树根
        def dfs(nums, l, r):
            if l > r:
                return None
            mid = l + r >> 1
            rv = TreeNode(nums[mid])
            rv.left = dfs(nums, l, mid - 1)
            rv.right = dfs(nums, mid + 1, r)
            return rv
        return dfs(nums, 0, len(nums) - 1)
```

## 二叉树类型的

明确dfs的参数、子问题、返回值、终止条件

比如 后序的这些：

- 翻转二叉树，定义TreeNode dfs(root) 翻转以root为根的树，返回翻转之后的结果。root.L = dfs(root.R) root.R = dfs(root.L)
- 二叉树的最大深度：定义int dfs(root) 返回以root为根的最大深度 ，返回max(dfs(root.L) ， dfs(root.R)) + 1
- 对称二叉树，定义boolean dfs(p, q) 判断两个树 是否对称  返回 p.val == q.val && dfs(p.left, q.right) && dfs(p.right, q.left) 
- 树的直径，dfs定义为 以root为根 到叶子结点的最长距离 ，返回max(dfs(L) ,dfs(R)) + 1
- 有序数组构造二叉搜索树， dfs(nums, l, r) 定义nums中选[l, r]中建树并返回树根
- [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) dfs(pl, pr, il, ir) 选择preorder[pl, pr] 和 inorder[il, ir]部分建立树

比如 中序的这些：

- [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)：dfs定义为当前root是否为二叉搜索树，先判断dfs(root.left) 再判断当前值和pre的关系，再判断dfs(root.right)
- [二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) 先dfs左边的，k--，k到0表示找到答案，并且可以返回了

比如：先右子树再左子树

- [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)：右视图 判断第一次到达某个深度 才添加到答案里 先递归右子树、再递归左子树

层序遍历：

- [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)：队列fifo

非递归的：

- [二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) 判断有无左子树，有左子树就先把左子树右链插入

# SQL进阶

## SQL的执行顺序

```sql
select distinct
       a.sex,
       b.city,
       count(1) as cnt,
       sum(salary) as sum1
from table1 a
join table2 b on a.id=b.id
where a.name=b.name
group by a.sex,b.city
having cnt>=2
order by a.sex,b.city
limit 10
```

执行顺序：

1. from 去加载table1和table2 两个表
2. join 和 on把两个表链接起来
3. where过滤条件
4. group by进行分组
5. 计算聚合 count 和 sum
6. having进行进一步过滤分组
7. distinct 去重
8. order by排序
9. limit取记录

## 行转列 group by + sum(if())

### 基础行转列

已知

| year | month | amount |
| ---- | ----- | ------ |
| 1991 | 1     | 1.1    |
| 1991 | 2     | 1.2    |
| 1991 | 3     | 1.3    |
| 1991 | 4     | 1.4    |
| 1992 | 1     | 2.1    |
| 1992 | 2     | 2.2    |
| 1992 | 3     | 2.3    |
| 1992 | 4     | 2.4    |

查成这样一个结果

| year | m1   | m2   | m3   | m4   |
| ---- | ---- | ---- | ---- | ---- |
| 1991 | 1.1  | 1.2  | 1.3  | 1.4  |
| 1992 | 2.1  | 2.2  | 2.3  | 2.4  |

```sql
create table table2(year int,month int ,amount double) ;

insert into table2
values (1991, 1, 1.1),
       (1991, 2, 1.2),
       (1991, 3, 1.3),
       (1991, 4, 1.4),
       (1992, 1, 2.1),
       (1992, 2, 2.2),
       (1992, 3, 2.3),
       (1992, 4, 2.4);

select *
from table2;
```

```sql
-- 临时表写法
with temp as (select *,
                   if(month = 1, amount, 0) as a,
                   if(month = 2, amount, 0) as b,
                   if(month = 3, amount, 0) as c,
                   if(month = 4, amount, 0) as d
            from table2)
select year, sum(a) m1 , sum(b) m2, sum(c) m3, sum(d) m4
from temp
group by year;

-- 子查询写法
select year, sum(a) m1, sum(b) m2, sum(c) m3, sum(d) m4
from (select *,
             if(month = 1, amount, 0) as a,
             if(month = 2, amount, 0) as b,
             if(month = 3, amount, 0) as c,
             if(month = 4, amount, 0) as d
      from table2) t
group by year;

-- 简化写法
SELECT year,
       SUM(IF(month = 1, amount, 0)) AS m1,
       SUM(IF(month = 2, amount, 0)) AS m2,
       SUM(IF(month = 3, amount, 0)) AS m3,
       SUM(IF(month = 4, amount, 0)) AS m4
FROM table2
GROUP BY year;
```

可以看看temp的数据：

![image-20240808122505153](img/%E6%89%8B%E6%92%95%E9%9D%A2%E8%AF%95/image-20240808122505153.png)

```sql
with temp as () -- 临时表
if(条件, 真值，假值) -- 三目表达式
```

### 带连接

```sql
-- 查询课程编号“2”的成绩比课程编号“1”低的所有同学的学号、姓名。
select sid, sname
from (select student_id,
             sum(if(course_id = 2, number, 0)) as cs2,
             sum(if(course_id = 1, number, 0)) as cs1
      from score
      group by student_id
      having cs2 < cs1) t1
         join student s on t1.student_id = s.sid;

-- 临时表写法
with temp as (select student_id,
                     sum(if(course_id = 2, number, 0)) as cs2,
                     sum(if(course_id = 1, number, 0)) as cs1
              from score
              group by student_id
              having cs2 < cs1)
select student.sid, student.sname
from temp
         join student
              on temp.student_id = student.sid;
```

### 数个数 group by + count(if(exp, true_val, null))

表table如下：

| DDate      | shengfu |
| ---------- | ------- |
| 2015-05-09 | 胜      |
| 2015-05-09 | 胜      |
| 2015-05-09 | 负      |
| 2015-05-09 | 负      |
| 2015-05-10 | 胜      |
| 2015-05-10 | 负      |
| 2015-05-10 | 负      |

如果要生成下列结果, 该如何写sql语句?

| DDate      | 胜   | 负   |
| ---------- | ---- | ---- |
| 2015-05-09 | 2    | 2    |
| 2015-05-10 | 1    | 2    |

 ```sql
 create table table1
 (
     DDate   varchar(20),
     shengfu varchar(20)
 );
 insert into table1
 values ('2015-05-09', "胜"),
        ('2015-05-09', "胜"),
        ('2015-05-09', "负"),
        ('2015-05-09', "负"),
        ('2015-05-10', "胜"),
        ('2015-05-10', "负"),
        ('2015-05-10', "负");
 -- count 里面必须是 null！数非null的个数
 select DDate,
        count(if(shengfu = "胜", 1, null)) as win,
        count(if(shengfu = "负", 1, null)) as lose
 from table1
 group by DDate;
 -- sum
 select DDate,
        sum(if(shengfu = "胜", 1, 0)) as win,
        sum(if(shengfu = "负", 1, 0)) as lose
 from table1
 group by DDate;
 ```

### 带字符串拼接

```sql
create table tableA
(
    qq   varchar(20),
    game varchar(20)
);
insert into tableA
values (10000, 'a'),
       (10000, 'b'),
       (10000, 'c'),
       (20000, 'c'),
       (20000, 'd');

create table tableB
(
    qq   varchar(20),
    game varchar(20)
);
insert into tableB
values (10000, 'a_b_c'),
       (20000, 'c_d');
       
-- A to B
select qq,
       group_concat(game SEPARATOR '_') as game
from tableA
group by qq;
```

## 连续N天登陆

### 查询出连续三天登录的人员姓名

![image-20240808132135725](img/%E6%89%8B%E6%92%95%E9%9D%A2%E8%AF%95/image-20240808132135725.png)

思路：

1. 先去重
2. 得到rn， row number（partition by name order by date)
3. date-rn -》 date_sub(interval rn day) date2
4. 按照date2, name 分组
5. count 大于N天的
6. 去重name

```sql
with t1 as (select distinct name, date
            from game), -- 去重
     t2 as (select *,
                   row_number() over (partition by name order by date) rn
            from t1), -- 得到rn
     t3 as (select *, date_sub(date, interval rn day) date2
            from t2) -- date - rn
select distinct name
from t3
group by name, date2 -- 分组
having count(1) >= 3;-- 计数
```

### 过去一个月内,曾连续两天活跃的用户

```sql
-- 建表
-- 表1 dau   记录了每日脉脉活跃用户的uid和不同模块的活跃时长
create table dau
(
    d               varchar(20),
    uid             int,
    module          varchar(20),
    active_duration int
);
insert into dau
values ('2024-08-01', 1, 'jobs', 324),
       ('2024-08-01', 2, 'feeds', 445),
       ('2024-08-01', 3, 'im', 345),
       ('2024-08-02', 2, 'network', 765),
       ('2024-08-02', 3, 'jobs', 342);
select *
from dau;

with t1 as (select DISTINCT d, uid
            from dau), -- 先 去重
     t2 as (select *,
                   date_sub(d, interval (row_number() over (partition by uid order by d)) day) dis -- date - rn(partition by uid order by d)
            from t1
            where d <= CURRENT_DATE() -- 筛选一个月以内的
              and d >= date_sub((CURRENT_DATE()), interval 30 day)),
     t3 as (select uid,
                   min(d)   `开始日期`,
                   max(d)   `结束日期`,
                   count(1) `连续登入天数`
            from t2
            group by uid, dis
            having count(*) >= 2)
select *
from t3;
```

![image-20240808135012384](img/%E6%89%8B%E6%92%95%E9%9D%A2%E8%AF%95/image-20240808135012384.png)

### 每个月每张卡连续消费的最大天数

有一张表C_T（列举了部分数据）表示持卡人消费记录，表结构如下：

| CARD NER  | VARCHAR2 | 卡号，     |
| --------- | -------- | ---------- |
| C_MONTH   | NUMBER   | 消费月份， |
| C_DATE    | DATE     | 消费日期， |
| C_TYPEVAR | CHAR2    | 消费类型   |
| C_ATM     | NUMBER   | 消费金额   |

 每个月每张卡连续消费的最大天数（如卡在当月只有一次消费则为1）。

连续消费天数：指一楼时间内连续每天都有消费，同一天有多笔消费算一天消费，不能跨月份统计。

```sql
create table c_t
(
    card_nbr varchar(20),
    c_month  varchar(20),
    c_date   varchar(20),
    c_type   varchar(20),
    c_atm    decimal
);
insert into c_t
values (1, '2022-01', '2022-01-01', '网购', 100),
       (1, '2022-01', '2022-01-02', '网购', 200),
       (1, '2022-01', '2022-01-03', '网购', 300),
       (1, '2022-01', '2022-01-15', '网购', 100),
       (1, '2022-01', '2022-01-16', '网购', 200),
       (2, '2022-01', '2022-01-06', '网购', 500),
       (2, '2022-01', '2022-01-07', '网购', 800),
       (1, '2022-02', '2022-02-01', '网购', 100),
       (1, '2022-02', '2022-02-02', '网购', 200),
       (1, '2022-02', '2022-02-03', '网购', 300),
       (2, '2022-02', '2022-02-06', '网购', 500),
       (2, '2022-02', '2022-02-07', '网购', 800);

select *
from c_t;

-- 去重 -> card_nbr,c_month绑定 得到rn -> date_sub -> count -> 按照cnt降序分组得到第一个 rn = 1
with t1 as (select distinct card_nbr, c_month, c_date from c_t),
     t2 as (select *, row_number() over (partition by card_nbr,c_month order by c_date) rn from t1),
     t3 as (select *, date_sub(c_date, interval rn day) dt2 from t2),
     t4 as (select dt2, card_nbr, c_month, count(1) cnt from t3 group by dt2, card_nbr, c_month),
     t5 as (select *, row_number() over (partition by card_nbr,c_month order by cnt desc) as rn from t4)
select card_nbr, c_month, cnt
from t5
where rn = 1;
```

## 分组内top前几

* 需求常见词：【每组xxx的第一个yyy的zzz】【每组xxx的最后一个】

  【每组xxx的前n个】【每组最xx的前n个】

* 公式：row_number() over(partition by 组名)  as rn，再筛选rn<=N名

### 求出每个部门工资最高的前三名员工

员工工号， 员工姓名，入职日期，员工薪水，部门编号

<img src="img/%E6%89%8B%E6%92%95%E9%9D%A2%E8%AF%95/image-20240808140603393.png" alt="image-20240808140603393" style="zoom:50%;" />

题目描述

求出每个部门工资最高的前三名员工，并计算这些员工的工资占所属部门总工资的百分比。

```sql
select temp.empno, temp.ename, temp.sal, temp.rn, temp.sum_sal, round(temp.sal / temp.sum_sal, 2) as rate
from (select *,
             row_number() over (partition by deptno order by sal desc) rn,
             sum(sal) over (partition by deptno)                  sum_sal
      from emp) temp
where rn <= 3;
```

子查询的结果如下：

<img src="img/%E6%89%8B%E6%92%95%E9%9D%A2%E8%AF%95/image-20240808141510124.png" alt="image-20240808141510124" style="zoom:50%;" />

### 20201201至今每日订单量top10的城市及其订单量

订单表，torder.  字段，user_id, order_id, ctime(10位时间戳)，city id，sale_num，sku_id(商品)

```sql
create table t_order (user_id string, 
                      order_id string, 
                      ctime string, 
                      city_id string, 
                      sale_num int , 
                      sku_id string) ;
with t1 as (select to_date(ctime) cdate, city_id, count(distinct order_id) cnt
            from t_order
            where to_date(ctime) >= '2020-12-01'
              and to_date(ctime) <= `current_date`()
            group by to_date(ctime), city_id),
     t2 as (select *, row_number() over (partition by cdate order by cnt desc) rn from t1)
select cdate, city_id, cnt
from t2
where rn <= 10;

-- mysql : select str_to_date('20220101', '%Y%m%d')
```

## 窗口函数

over关键字 代表定义窗口

用法：函数名（字段名）over (partition by xxx, yyy order by zzz)

- 聚合类窗口函数
  - Sum() over()
  - Count/avg/max/min 
- 排序类
  - Row_number/ rank/ dense_rank
- 偏移类
  - Lag/ lead

Emp表的表数据如下：

| NAME | MONTH | AMT  |
| ---- | ----- | ---- |
| 张三 | 01    | 100  |
| 李四 | 02    | 120  |
| 王五 | 03    | 150  |
| 赵六 | 04    | 500  |
| 张三 | 05    | 400  |
| 李四 | 06    | 350  |
| 王五 | 07    | 180  |
| 赵六 | 08    | 400  |

问题：请写出可以得到以下的结果SQL

| NAME | 总金额 | 排名 | 占比   |
| ---- | ------ | ---- | ------ |
| 赵六 | 900    | 1    | 40.91% |
| 张三 | 500    | 2    | 22.73% |
| 李四 | 470    | 3    | 21.36% |
| 王五 | 330    | 4    | 15.00% |

```sql
with t1 as (select name,
                   sum(amt) sum_amt
            from emp
            group by name),
     t2 as (select *,
                   row_number() over (order by sum_amt desc) rn,
                   sum_amt / sum(sum_amt) over ()            rate
            from t1)
select name as '姓名', sum_amt as '总金额', rn as '排名', concat(round(rate * 100, 2), '%') as '占比'
from t2;
```

在第一题员工表的基础上，统计每年入职总数以及截至本年累计入职总人数。

截至本年累计入职总人数=本年总入职人数 + 本年之前所有年的总入职人数之和

<img src="img/%E6%89%8B%E6%92%95%E9%9D%A2%E8%AF%95/image-20240808144256360.png" alt="image-20240808144256360" style="zoom:50%;" />

```sql
select *,
       sum(cnt) over (order by year1) cnt2
from
    (select year(hiredate) as year1,
            count(1) as cnt
     from emp
     group by year(hiredate)) a;
```

## 带条件的聚合统计

要求：编写SQL能运行，数据正确且符合规范，如遇到自定义函数或不记得的函数可以用XX代替

1.已知有如下两个表表sale：字段如下

```sql
Create table sale_order(
    Order_id bigint comment '订单ID',
    User_id bigint comment '用户ID',
    Order_status int,
    Create_time string,
    Last_update_time string,
    Product_id bigint,
    Product_num bigint 
);
```

用户注册表：

```sql
Create table user_info(
    user_id bigint comment'用户ID，唯一主键',
    sex string.
    age int
);

```

问题：用一条SQL生成完整的用户画像表，包含如下字段：

user_id,  sex,  age,  d7order_num,   d14_order_num，后面两个字段分别为近7天订单数量，近14天订单数量。

```sql
create table sale_order(
    order_id bigint comment '订单ID',
    user_id bigint comment '用户ID',
    order_status int ,
    create_time string,
    last_update_time string,
    product_id bigint,
    product_num bigint
);
create table user_info(
    user_id bigint comment '用户ID,唯一主键',
    sex string,
    age int
);

select u.user_id,
       s.d7order_num,
       s.d14order_num
from user_info u
left join (select user_id,
                  count(if(create_time >= '7天前'  and create_time <= '今天', order_id,null)) as d7order_num,
                  count(if(create_time >= '14天前' and create_time <= '今天', order_id,null)) as d14order_num
           from sale_order
           where create_time >= '14天前'
           group by user_id) s on u.user_id = s.user_id;
```

# hot100

## 哈希

[1. 两数之和](https://leetcode.cn/problems/two-sum/) a[i] + a[j] = t  枚举i，找到 t - a[i] 是否存在， 由于需要返回下标，所以map存储(t - a[i], i)

- 类似的还有 和为k的子数组 （等价于 s[j] - s[i] = k) 前缀和的思想

[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

- **字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。eat tea tae
- char[] w = s.toCharArray(), Arrays.sort(w), String s = String.valueOf(w) 拿到相同的单词，再用哈希表判断就是了
- 用 map.computeIfAbsent(key, e -> new ArrayList<>()).add(val); 去简化判断
- new ArrayList<>(map.values()) 返回一个List<List<>

（❌）[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

- 要求O(N)的算法，就不能用排序了
- 思路：1. 入set，2，遍历每个元素，判断当前是不是起点（set.contains(x -1 ))，如果是起点， 就从后面找while(set.contains(++x)) cur ++，如果不是起点的话，一定会有一次已经包括进去，不需要重复计算。

## 双指针

[283. 移动零](https://leetcode.cn/problems/move-zeroes/)

- 经典双指针， 指针i指向元素存放位置， 指针j往后扫，不是0的话，填到i上，最后记得填充i之后的

[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

- i， j往中间扫，每次更新ans=max(ans, min(h[i],h[j]) * (j - i))， 截止条件是：i == j 所以 while(i < j)

（❌）[15. 三数之和](https://leetcode.cn/problems/3sum/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

- 固定i， 找到满足nums[j] + nums[k] == -nums[i]的数， 后面这一步可以用双指针去找
- 问题1: 如何不重复，如果nums[i]和前面的数相同，就不做处理了i > 0 && nums[i] == nums[i - 1]
- 问题2：怎么剪纸 if（nums[i] > 0) 因为有序， 所以第一个数>0了，后面必然不可能
- 问题3: i和j的相同数跳过的逻辑: while(l < r && nums[l] == nums[l + 1])l ++; 最后还要一次l ++;

（❌）[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

<img src="img/%E6%89%8B%E6%92%95%E9%9D%A2%E8%AF%95/image-20240813164145786.png" alt="image-20240813164145786" style="zoom:50%;" />

- 怎么定义可以接到的雨水面积： 假设当前x，min(左边比x大的最大值, 右边比x大的最大值） - x

```java
class Solution {
    public int trap(int[] h) {
        int n = h.length;
        if(n <= 2) return 0;
        int[] l = new int[n];
        int[] r = new int[n];

        l[0] = h[0]; r[n - 1] = h[n - 1];
        for(int i = 1; i < n; i ++) l[i] = Math.max(h[i], l[i - 1]);
        for(int i = n - 2; i >= 0; i --) r[i] = Math.max(h[i], r[i + 1]);

        int res = 0;
        for(int i = 0; i < n; i ++) {
            res += Math.min(l[i], r[i]) - h[i];
        }
        return res;
    }
}
```

## 滑动窗口

[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。

- 滑动窗口的基本模版

  ```java
  class Solution {
      public int lengthOfLongestSubstring(String s) {
          char[] w = s.toCharArray();
          int res = 0;
          int n = w.length;
          int[] cnt = new int[128];
          for(int i = 0, j = 0; i < n; i ++) {
              cnt[w[i]] ++;
              while(cnt[w[i]] > 1) { // 不满足条件 开始移左指针
                  cnt[w[j ++]] --;
              }
            // 退出循环 表示此时窗口满足while条件
              res = Math.max(res, i - j + 1);
          }
          return res;
      }
  }
  ```
  

（❌）[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int[] pCnt = new int[26];
        // 字符的种类、每个种类的个数都要相同
        List<Integer> res = new ArrayList<>();
        char[] ws = s.toCharArray();
        char[] ps = p.toCharArray();
        for(char x : ps) {
            pCnt[x - 'a'] ++;
        }
        
        for(int i = 0, j = 0; i < ws.length; i ++) {
            pCnt[ws[i] - 'a'] --;
            while(pCnt[ws[i] - 'a'] < 0) {
                pCnt[ws[j ++] - 'a'] ++;
            }
          // 满足次数条件， 检查是否满足 长度条件
            if(i - j + 1 == ps.length) {
                res.add(j);
            }
        }
        return res;
    }
}
```

## 子串

（❌）[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 该数组中和为 `k` 的子数组的个数。子数组是数组中元素的连续非空序列。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        // s[j] - s[i] = k
        // 找到是否满足 s[i] + k = s[j]
        
        // s[j] - k
        int n = nums.length;
        int[] s = new int[n + 1];
        for(int i = 1; i <= n; i ++) {
            s[i] = s[i - 1] + nums[i - 1];
        }
        int ans = 0;
        Map<Integer, Integer> cnt = new HashMap<>();
        for(int x : s) {
            ans += cnt.getOrDefault(x - k, 0);
            cnt.merge(x, 1, Integer::sum);
        }
        return ans;
    }
}
```

（❌）[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

<img src="img/%E6%89%8B%E6%92%95%E9%9D%A2%E8%AF%95/image-20240813212610645.png" alt="image-20240813212610645" style="zoom:50%;" />

- 暴力做法，对于每个滑动窗口，ok的时间复杂度找到最大值
- 优先队列做法，维护大根堆
- 单调队列：内涵：每过一年，队伍里年龄超出时间区间的踢了，队尾能力小于新人的也踢了！然后加入新人！新人一定得是队伍里最年轻（下标最靠右）且能力最弱（值最小）的，如果有比新人能力还弱的前辈，对不起了，操刀！

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        Deque<Integer> q = new ArrayDeque<>();
        for(int i = 0; i < n; i ++ ){
            // 淘汰队尾比新人能力弱的
            while(!q.isEmpty() && nums[q.getLast()] <= nums[i]) {
                q.removeLast();
            }
            // 加入新人
            q.addLast(i);
            // 判断老人又没有超出时间
            if(i - q.getFirst() >= k) {
                q.removeFirst();
            }

            // 记录答案
            if(i >= k - 1) {
                ans[i - (k - 1)] = nums[q.getFirst()];
            }
        }
        return ans;
    }
}
```

（❌）[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```java
class Solution {
    public String minWindow(String S, String t) {
        char[] s = S.toCharArray();
        int n = s.length;
        int l = -1, r = n;
        int[] cntS = new int[128];
        int[] cntT = new int[128];
        for(char c : t.toCharArray()) {
            cntT[c]++;
        }
        
        for(int i = 0, j = 0; i < n; i ++) {
            cntS[s[i]]++;
          // 这部分可以优化， 用一个变量去判断，初始化的时候
          // 记录有less种字母的
          // 每次 ++cntS[c] == cntT(c) less--
          // while(less == 0) { ... if(cntS[x]-- == cntT[x]) less++}
            while(isCovered(cntS, cntT)) {
                if(i - j < r - l) {
                    l = j;
                    r = i;
                }
                cntS[s[j++]]--;
            }
        }
        return l < 0 ? "" : S.substring(l, r + 1);
    }
    private boolean isCovered(int[] cntS, int[] cntT) {
        for(int i = 'A'; i <= 'Z'; i ++) {
            if(cntS[i] < cntT[i]) {
                return false;
            }
        }
        for(int i = 'a'; i <= 'z'; i ++) {
            if(cntS[i] < cntT[i]) {
                return false;
            }
        }
        return true;
    }
}
```

## 普通数组

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**子数组**是数组中的一个连续部分。

- f[i] 表示以i结尾的最大子数组的和
- f[i] = nums[i] + max(f[i - 1], 0)
- 考虑优化 用变量表示之前的和

```java
class Solution {
    public int maxSubArray(int[] nums) {
        // -2 1 -3 4 -1 2 1 -5  4
        // -2 1 -2 4 3 5 6 1 5
        // f[i] 表示以i结尾的最大子数组和
        // f[i] = nums[i] + max(f[i - 1], 0)
        int n = nums.length;
        int[] f = new int[n];
        f[0] = nums[0];
        int ans = f[0];
        for(int i = 1; i < n; i ++) {
            f[i] = nums[i] + Math.max(f[i - 1], 0);
            ans = Math.max(ans, f[i]);
        }
        return ans;
    }
}

class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int pre = 0;
        for(int x : nums) {
            pre = Math.max(pre + x, x);
            ans = Math.max(ans, pre);
        }
        return ans;
    }
}
```

（❌）[56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

- 按每个小区间的起点升序排序， 维护start和end是即将要加入list的区间起始和终点
- 对于每个区间，判断区间的起点和end，如果起点 > end表示不相交，加入res，重新设置start和end
- 否则，就把end更新为 当前终点和end的最大值

```java
class Solution {
    public int[][] merge(int[][] its) {
        // 按照its[0] 排序
        Arrays.sort(its, (o1, o2) -> o1[0] - o2[0]);
        
        List<int[]> ans = new ArrayList<>();
        int start = its[0][0];
        int end = its[0][1];

        for(int i = 1; i < its.length; i ++) {
            // 如果起点 > 前一个的end，就把前一个加入
            if(its[i][0] > end) {
                ans.add(new int[]{start, end});
                start = its[i][0];
                end = its[i][1];
                continue;
            }
            
            end = Math.max(its[i][1], end);
            // 否则 有覆盖，end = max(cur_end, end)
        }
      // res.toArray(new int[res.size()][]);
        ans.add(new int[]{start, end});
        int size = ans.size();
        int[][] res = new int[size][2];
        for(int i = 0; i < size; i ++) {
            res[i] = ans.get(i);
        }
        return res;
    }
}
```

[189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
```

- 原地算法 swap(nums, 0, n -1 ) ; swap(nums, 0,k -1); swap(nums, k, n -1 )
- O（N）空间  new_arr[(i + k) % n] = nums[i]

[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

- 类似前缀和的思想， 预处理前后缀的乘积
- O（N）时间复杂度

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] l = new int[n];
        int[] r = new int[n];
        
        l[0] = nums[0]; r[n - 1] = nums[n - 1];
        for(int i = 1; i < n; i ++) l[i] = l[i - 1] * nums[i];
        for(int i = n - 2; i >= 0; i --) r[i] = r[i + 1] * nums[i];
        // 1 2 6 24
        //24 24 12 4
        // 对于每个i位置 res[i] = f[i - 1] * r[i + 1]
        int[] res = new int[n];
        res[0] = r[1];
        res[n - 1] = l[n - 2];
        for(int i = 1; i < n - 1; i ++) {
            res[i] = l[i - 1] * r[i + 1];
        }
        return res;
    }
}
```

[41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
