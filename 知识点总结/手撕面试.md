# 单例模式

### 双重检查锁

用双重检查锁的方式实现单例模式：

```java
public class Singleton {
	//注意使用volatile防止指令重排序
    private volatile static Singleton instance;
	//私有化构造方法，单例模式基本操作
    private Singleton() {
    }
	//静态获取单例的方法
    public  static Singleton getInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (instance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

使用`volatile`的原因：防止指令重排序。

> `instance= new Singleton();`这一步，是一个实例化的过程，底层其实分为三部执行：
>
> 1. 为instance分配内存空间：`memory = allocate();`
> 2. 实例化instance。`ctorInstance(memory);`
> 3. 将instance指向分配的内存地址。`instance = memory;`

由于JVM具有指令重排序的特性，指令的执行顺序可能会变成1，3，2。在多线程环境下，可能某个线程可能会得到未初始化的实例。

举个例子：加入线程A执行了1和2之后，线程B调用getInstance的时候，会发现instance不为null，会直接返回这个没有执行过指令3的实例。

### 静态内部类

```java
public class Singleton {
    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }

    /**
     * 静态内部类
     */
    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }
}
```

第一次加载Singleton类时不会初始化实例，只有在第一次调用getInstance方法时，虚拟机才会加载holder。

既保证线程安全，也保证单例对象唯一，也实现延迟初始化。

### 枚举单例

double check和静态内部类的写法都不错，但是都不能防止被反序劣化生成多个实例。

但枚举单例可以！

```java
public enum SingletonEnum {
    INSTANCE;
}
```

默认枚举实例的创建是线程安全的，即使**反序列化**也不会生成新的实例，**任何情况下都是一个单例**。

# 快排、归并

归并

```java
    private void merge(int[] q, int l, int r) {
        if(l >= r) return;
        int mid = l + r >> 1;
        merge(q, l, mid);
        merge(q, mid + 1, r);
        int[] tmp = new int[r - l + 1];

        int k = 0, i = l, j = mid + 1;
        while(i <= mid && j <= r)
            if(q[i] <= q[j]) tmp[k++] = q[i++];
            else tmp[k++] = q[j++];

        while(i <= mid) tmp[k++] = q[i++];
        while(j <= r) tmp[k++] = q[j++];

        for(i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
    }
```

快排

```java
    void quickSort(int[] q, int l, int r) {
        if(l >= r) return;
        int i = l - 1, j = r + 1, x = q[l + r >> 1];
        while(i < j) {
            do i++; while(q[i] < x);
            do j--; while(q[j] > x);
            if(i < j) swap(q, i, j);
        }
        quickSort(q, l, j);
        quickSort(q, j + 1, r);

    }
```



```java
    int p(int[] x, int l, int r) {
        int i = l, j = r, t = x[l];
        while(i < j) {
            while(i < j && x[j] >= t) {
                j --;
            }
            if(i < j) {
                x[i] = x[j];
                i ++;
            }
            while(i < j && x[i] < t) {
                i ++;
            }
            if(i < j) {
                x[j] = x[i];
                j --;
            }
        }
        x[i] = t;
        return i;
    }
    void qs(int[] x, int l, int r) {
        if(l >= r) return;
        int pivot = p(x, l, r);
        qs(x, l, pivot - 1);
        qs(x, pivot + 1, r);
    }
```

LC3无重复字符的最长子串

LC93 复原IP地址

LC415 字符串相加（大数相加，记得进位1）

LCR181 字符串中的单词反转

LC15 三数之和

LC39组合综合

LC40组合总和2

LC215 数组中的第k个最大元素

LC704 二分查找

LC121 买卖股票的最佳时机

LC53 最大子数组和

LC20 有效的括号

LCR090打家劫舍2

LC165比较版本号

LC189 轮转数组

LC124 二叉树中的最大路径和

```java
```



LC82 删除排序链表中的重复元素2

LC5最长回文子串

LC146 LRU机制

LC1120 子数的最大平均值

LC509 斐波那契数



# 非递归中序遍历

思路：左子树一直往左走，入栈，直到走到null。 退回一步，入答案，往右子树走一步

```java
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stk = new Stack<>();
        while(root != null || !stk.isEmpty()) {
            if(root != null) {
                stk.push(root);
                root = root.left;
            } else {
                root = stk.pop();
                res.add(root.val);
                root = root.right;
            }
        }
        return res;
    }
```

# python写法

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        # 选择[l, r] 的树，返回树根
        def dfs(nums, l, r):
            if l > r:
                return None
            mid = l + r >> 1
            rv = TreeNode(nums[mid])
            rv.left = dfs(nums, l, mid - 1)
            rv.right = dfs(nums, mid + 1, r)
            return rv
        return dfs(nums, 0, len(nums) - 1)
```

# 二叉树类型的

明确dfs的参数、子问题、返回值、终止条件

比如 后序的这些：

- 翻转二叉树，定义TreeNode dfs(root) 翻转以root为根的树，返回翻转之后的结果。root.L = dfs(root.R) root.R = dfs(root.L)
- 二叉树的最大深度：定义int dfs(root) 返回以root为根的最大深度 ，返回max(dfs(root.L) ， dfs(root.R)) + 1
- 对称二叉树，定义boolean dfs(p, q) 判断两个树 是否对称  返回 p.val == q.val && dfs(p.left, q.right) && dfs(p.right, q.left) 
- 树的直径，dfs定义为 以root为根 到叶子结点的最长距离 ，返回max(dfs(L) ,dfs(R)) + 1
- 有序数组构造二叉搜索树， dfs(nums, l, r) 定义nums中选[l, r]中建树并返回树根
- [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) dfs(pl, pr, il, ir) 选择preorder[pl, pr] 和 inorder[il, ir]部分建立树

比如 中序的这些：

- [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)：dfs定义为当前root是否为二叉搜索树，先判断dfs(root.left) 再判断当前值和pre的关系，再判断dfs(root.right)
- [二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) 先dfs左边的，k--，k到0表示找到答案，并且可以返回了

比如：先右子树再左子树

- [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)：右视图 判断第一次到达某个深度 才添加到答案里 先递归右子树、再递归左子树

层序遍历：

- [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)：队列fifo

非递归的：

- [二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) 判断有无左子树，有左子树就先把左子树右链插入