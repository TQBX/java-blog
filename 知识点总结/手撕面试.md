# 单例模式

### 双重检查锁

用双重检查锁的方式实现单例模式：

```java
public class Singleton {
	//注意使用volatile防止指令重排序
    private volatile static Singleton instance;
	//私有化构造方法，单例模式基本操作
    private Singleton() {
    }
	//静态获取单例的方法
    public  static Singleton getInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (instance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

使用`volatile`的原因：防止指令重排序。

> `instance= new Singleton();`这一步，是一个实例化的过程，底层其实分为三部执行：
>
> 1. 为instance分配内存空间：`memory = allocate();`
> 2. 实例化instance。`ctorInstance(memory);`
> 3. 将instance指向分配的内存地址。`instance = memory;`

由于JVM具有指令重排序的特性，指令的执行顺序可能会变成1，3，2。在多线程环境下，可能某个线程可能会得到未初始化的实例。

举个例子：加入线程A执行了1和2之后，线程B调用getInstance的时候，会发现instance不为null，会直接返回这个没有执行过指令3的实例。

### 静态内部类

```java
public class Singleton {
    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }

    /**
     * 静态内部类
     */
    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }
}
```

第一次加载Singleton类时不会初始化实例，只有在第一次调用getInstance方法时，虚拟机才会加载holder。

既保证线程安全，也保证单例对象唯一，也实现延迟初始化。

### 枚举单例

double check和静态内部类的写法都不错，但是都不能防止被反序劣化生成多个实例。

但枚举单例可以！

```java
public enum SingletonEnum {
    INSTANCE;
}
```

默认枚举实例的创建是线程安全的，即使**反序列化**也不会生成新的实例，**任何情况下都是一个单例**。

# 快排、归并

归并

```java
    private void merge(int[] q, int l, int r) {
        if(l >= r) return;
        int mid = l + r >> 1;
        merge(q, l, mid);
        merge(q, mid + 1, r);
        int[] tmp = new int[r - l + 1];

        int k = 0, i = l, j = mid + 1;
        while(i <= mid && j <= r)
            if(q[i] <= q[j]) tmp[k++] = q[i++];
            else tmp[k++] = q[j++];

        while(i <= mid) tmp[k++] = q[i++];
        while(j <= r) tmp[k++] = q[j++];

        for(i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
    }
```

快排

```java
    void quickSort(int[] q, int l, int r) {
        if(l >= r) return;
        int i = l - 1, j = r + 1, x = q[l + r >> 1];
        while(i < j) {
            do i++; while(q[i] < x);
            do j--; while(q[j] > x);
            if(i < j) swap(q, i, j);
        }
        quickSort(q, l, j);
        quickSort(q, j + 1, r);

    }
```



```java
    int p(int[] x, int l, int r) {
        int i = l, j = r, t = x[l];
        while(i < j) {
            while(i < j && x[j] >= t) {
                j --;
            }
            if(i < j) {
                x[i] = x[j];
                i ++;
            }
            while(i < j && x[i] < t) {
                i ++;
            }
            if(i < j) {
                x[j] = x[i];
                j --;
            }
        }
        x[i] = t;
        return i;
    }
    void qs(int[] x, int l, int r) {
        if(l >= r) return;
        int pivot = p(x, l, r);
        qs(x, l, pivot - 1);
        qs(x, pivot + 1, r);
    }
```

LC3无重复字符的最长子串

LC93 复原IP地址

LC415 字符串相加（大数相加，记得进位1）

LCR181 字符串中的单词反转

LC15 三数之和

LC39组合综合

LC40组合总和2

LC215 数组中的第k个最大元素

LC704 二分查找

LC121 买卖股票的最佳时机

LC53 最大子数组和

LC20 有效的括号

LCR090打家劫舍2

LC165比较版本号

LC189 轮转数组

LC124 二叉树中的最大路径和

LC82 删除排序链表中的重复元素2

LC5最长回文子串

LC146 LRU机制

LC1120 子数的最大平均值

LC509 斐波那契数