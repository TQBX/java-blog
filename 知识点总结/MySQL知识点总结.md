[toc]



# 存储引擎MyISAM与InnoDB的区别

## MyISAM

不支持事务，但每次查询都是原子的。

支持表级锁，每次操作是对整个表加锁。

存储表的总行数，count速度很快。

拥有三个文件：索引文件、表结构文件、数据文件。

非聚簇索引：索引文件得数据域存储指向数据文件的指针，辅助索引与主索引基本一致，但辅助索引不用保证唯一性。

## InnoDB

支持ACID的事务，支持事务的四种隔离级别。

支持行级锁及外键约束：因此可以支持写并发。

不存储总行数。

一个InnoDB引擎存储在一个文件空间【共享表空间，表大小不受操作系统的控制，一个表可能分布在多个文件里】，也有可能为多个【设置为独立表空间，表大小受操作系统文件大小限制，一般为2G】受操作系统文件大小的限制。

主键索引采用聚集索引【索引的数据域存储数据文件本身】，辅助索引的数据域存储主键的值。因此从辅助索引查找数据，需要现通过辅助索引找到主键值，再访问辅助索引。最好使用自增主键，防止插入数据时，为维持B+树结构，文件大调整。

```
    1. 【是否支持行锁】
        MyISAM 仅支持表锁， InnoDB支持表锁和行锁
        
    2. 【是否支持事务】 
        MyISAM不支持事务，且不具备【崩溃恢复能力】。
        InnoDB 支持事务，提供回滚和崩溃恢复。
    
    3. 【是否支持外键】
        仅InnoDB支持外键 
    4. 【是否支持MVCC】
        仅InnoDB支持MVCC
    
    5. 【应用场景不同】
        MyISAM 适用 【Select】频繁，并发少
        InnoDB 适用 【Insert Delete Update】频繁，高并发

        因为 
        (1) MyISAM 仅缓存索引块，而InnoDB缓存 {索引+数据}
        (2) InnoDB 回表需要映射块，而MyISAM 直接映射数据地址
        (3) InnoDB 需要维护MVCC机制
        
    6.  MyISAM索引 和 InnoDB 索引 区别
        MyISAM 【索引】 叶子节点 = {key ， 行数据地址}
        
        InnoDB 【主键索引】 叶子节点 = {主键ID ， data数据}
        因此 InnoDB根据【主键】索引查询，不需要二次寻址，效率更高
        
        InnoDB 【二级索引】 叶子节点 = {key, 主键ID}
        如果实现索引覆盖，即 要查询列值 全部命中索引，则直接返回 非主键索引的内容
        如果未实现索引覆盖，则需要根据【主键ID】做回表
    
    7.  【存储结构不同】
        InnoDB 存储结构 = 索引和数据 集中存储
        MyISAM存储结构 = {表定义，MYD数据文件，MYI索引文件}
    
    8.  不带WHERE条件时，【count(*)效率不同 】
        MyISAM 自带计数器存储保存【总行数】，可直接返回结果
        InnoDB 扫描全表计算总行数
        
    
```

# 事务及隔离级别

什么是事务：逻辑上的一组操作，要么都执行，要么都不执行，具有ACID四大特性。

## ACID特性

AID是数据库的特征，通过AID手段保证C这个最终目的。（AID是手段、C是目的！）

```
    1. Atomicity 原子性
        事务是不可分割的最小单元，事务内所有操作要么全部执行成功，要么全部失败回滚

    2. Isolation 隔离性
        事务所作出的修改，在提交前，对于其他事务而言不可见
        
    3. Durability 持久性
        事务一旦提交，所作出的修改是永久的。
        
    4. Consistency 一致性
        系统从一个正确状态-->另一个正确状态
        
        
       【数据库】约束列值 不能小于0，则事务执行失败
       【应用层】约束 余额数据不能小于0，则应用层通过事务回滚保证约束
       
       没有约束，则事务执行成功，且保持了一致性。因为没有破坏约束。
       
  
```

## ACID如何保证

A原子性由undo log日志保证，记录了需要回滚的日志信息，事务回滚时撤销已经执行的sql。

C一致性由其他三大特性保证、程序代码需要保证业务上的一致性。

I隔离性由MVCC来保证。

D持久性由**内存+redolog**来保证，mysql修改数据同时再内存和redolog记录这次操作，宕机的时候可以从redolog恢复。

```
InnoDB redolog 写盘，InnoDB事务进入prepare状态

如果前面的prepare成功， binlog写盘，再继续将事务日志持久化到binlog，如果持久化成功，事务则进入commit状态（在redolog 里面写一个commit记录）

redolog的刷盘会在系统空闲时进行。
```

## 并发事务带来的问题

1. 【脏读】 事务A 修改数据，但并未commit。而事务B读取该数据。 
2. 【丢失修改】 事务A 、B都读取同一个数据。事务A 、B先后修改数据，则 第一次修改操作丢失。
3. 【不可重复读】 事务A 共读取两次数据，而在这两次读取之间。事务B修改了数据。则事务A两次读取到的数据不同。
4. 【幻读】 事务A 读取某数据不存在，事务B正好插入该条数据。事务A试图插入该数据发生冲突，就和产生幻觉一样。

## 幻读和不可重复读的区别

- 不可重复读的重点是内容修改（update）或者记录减少（delete）比如多次读取一条记录发现其中某些记录的值被修改；
- 幻读的重点在于记录新增（insert）比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。

Javaguide：幻读可以看作是不可重复读的一种特殊情况，单独区分是因为，解决它们的方案不一样

- update or delete操作，直接对记录加锁就可以保证事务安全
- insert，由于记录锁只能锁住已经存在的记录，避免插入新纪录，需要依赖gap lock。需要record + gap == next-key lock

幻读演示：

```sql
事务A
set autocommit = 0;
begin;
select * from t_user where id = 5; -- 没有数据

事务B
begin;
insert into t_user values(5, 'haha', 'haha');
commit;

事务A
insert into t_user values(5, 'hyh', 'hyh'); 
-- Duplicate entry '5' for key 't_user.PRIMARY'
select * from t_user where id = 5; -- 还是没有数据，但就是插不进去，跟鬼一样
```

## 事务隔离级别

查看事务隔离级别：

```sql
select @@transaction_isolation; 
show variables like 'transaction_isolation';
```

修改事务的隔离级别

```sql
set [session | global] transaction isolation level 
{READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE};
```

事务使用

```sql
begin;
select * from user;
commit || rollback;
```

查看有多少事务正在运行

```sql
select * from information_schema.innodb_trx;
```

```
    1. Read-Uncommitted 读取未提交
        无论事务是否提交，直接【读取主记录】 
        即并发问题 =【脏读】+【不可重复读】+【幻读】
    2. Read-committed 读取已提交
        【读取最新版本的快照】，快照是事务提交后产生，但可能存在同一事务两次读取的快照不同。
        即并发问题 = 【不可重复读】+【幻读】
    3. Repeatable 可重复读
        【读取指定版本快照】，则事务多次读取某数据行的结果一致，但读取到的数据可能并非最新数据 。
        即并发问题 = 【幻读】
    4. Serializable 可串行化 
        上表锁，读写相互阻塞。效率低下。
        无并发问题 
        
    InnoDB引擎默认实现 可重复读隔离级别  Oracle默认是读已提交
    
    四种隔离级别都是有存在的意义的，根据具体场景选择。
```

## undo log 和redo log的区别

> redo log 记录的是 数据页的物理变化，服务宕机 可用来同步数据
>
> undo log 记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据
>
> redo log保证了事务的持久性，undo log保证了事务的原子性和一致性

![image-20240726212748139](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726212748139.png)

### redo log 重做日志（物理日志）

![image-20240726213227990](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726213227990.png)

### undo log 回滚日志（逻辑日志）

![image-20240726213416903](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726213416903.png)

## 隔离性怎么保证？

MVCC 和 排他锁（如果一个事务获取了一个数据行的排他锁，其他的事务就不能再获取）

### MVCC

多版本并发控制，维护一个数据的多个版本，使得读写操作没有冲突。

MVCC的具体实现，依赖于数据库记录中的：隐式字段、undo log日志、readView

![image-20240726235250413](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726235250413.png)

![image-20240726235351881](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726235351881.png)



```
【概念】：
 多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链。

【目的】 ： 
    MVCC是行锁的变种，它想要尽可能地避免加锁操作，实现【非阻塞】读。从而提高处理并发事务的性能

【MVCC 实现的隔离级别】
    MVCC仅 Read Committed & REPEATABLE READ 两种隔离级别
    READ UNCOMMITTED 总是【读取最新】数据行 ，与MVCC的版本快照机制不符
    SERIALIZABLE 则 对读取的【数据行】都加锁 ，与MVCC 尽可能避免加锁的原则不符
    
【undolog】 记录数据行的某个历史版本，undolog以链表形式存在

RC 是读取 最新版本的 undolog
RR 是读取 某一指定老版本的undolog

【三个字段】
row_id: 隐含的自增id，数据库默认为该行记录生成的唯一隐式主键
trx_id: 用来存储每次对某条聚簇索引记录进行修改的时候的事务id。
roll_pointer: 回滚指针，配合undolog，指向上一版本
```

![image-20210327151321694](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327151321694.png)

# 索引

## 索引类型

> 按照三种分：功能逻辑、字段数量、物理实现

功能逻辑分：普通、唯一（uq）、主键（uq + not null）、全文

- 普通索引：允许被索引的数据列包含重复的值。

- 唯一索引：记录唯一性。

- 主键索引：特殊的唯一索引，一张表只能定义一个主键索引，主键用于唯一标识一条记录，使用primary key创建。

- 全文索引：倒排索引，极大提升检索效率，解决判断字段是否包含的问题。alter table tb_user add fulltext(col) 只支持英文，通常可以用es和solr去做搜索

字段数量分：单一、联合（注意最左前匹配原则）

- 联合索引：索引可以覆盖多个列，index(col1, col2)索引。

物理实现分：聚簇索引、非聚簇索引（二级索引）

- 聚簇索引：数据和索引放到一块，主键一定是聚簇索引，B+树叶子结点保存整行数据
- 非聚簇索引：数据和索引分开存储，B+树叶子结点保存对应的主键，一般自己定义的索引

## 对性能的影响

1. 极大提高数据的查询速度。

2. 使用索引，在查询过程种，使用优化隐藏器，提高性能。
3. 会降低插入、删除、更新表的速度，因为在执行写操作时，还需要操作索引文件。
4. 索引需要占物理空间，除了数据表占数据空间之外，每个索引还有占一定的物理空间，如果要建立聚簇索引，那么需要空间就会更大，如果非聚簇索引很多，一旦聚簇索引改变，非聚簇索引也会跟着变。

## B树和B+树的区别

评价索引的数据结构设计好坏：数据落到硬盘（持久化），索引需要尽可能**减少IO次数**

```
1.  Mysql根据【磁盘IO次数】衡量查询效率，而【B+树磁盘IO次数更少】

    因为 B+树中【 非叶节点 = { 指针+key } 】
    而B树中 【非叶节点 = { 指针+ key + data数据 }】,
    每个节点(即每一页) 存储空间有限，B树节点存储的key较少，出度较小
    因此B树的节点较多(key总量固定)
    导致B树深度较大，磁盘IO次数多。
    
2.  B+树叶子节点通过指针连接（有序链表！），便于【区间访问】
```

**B树**

![1584071014(1)](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1584071014(1).png)

**B+树**

![1584071033(1)](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1584071033(1).png)

每个磁盘块包含蓝色的指针和几个紫色数据项。

但这里的紫色数据项只是标识指针的范围，即p1 标识小于28的磁盘块，p2标识大于28的磁盘块。

非叶子节点并不存储真实的数据，只存储指引搜索方向的指针。

真实的数据在叶子节点。

> 3层的b+树可以表示上百万的数据，需要三次IO,性能提升巨大。

## 为什么是B+树，而不是红黑树？

B+树磁盘IO次数更少。

1. 红黑树的深度往往较大，磁盘IO次数和树高度成正比。
2. B树利用磁盘预读取特性，在建立节点时，申请物理连续的一页空间【磁盘预读取的多个磁盘款的总和】，从而实现一次磁盘IO读取一个节点，减少磁盘IO次数。 但红黑树逻辑较近的节点，其物理距离可能较远，无法利用磁盘预读取的特性。

## 索引的创建原则

先说一下自己实际工作中怎么用的，比如：主键索引、唯一索引、联合索引

![image-20240726202131965](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726202131965.png)

## 索引失效的情况

说自己遇到过的，explain判断是否失效

> 1. 违反最左前缀
> 2. 范围查询右边的列
> 3. 运算操作
> 4. 类型转换
> 5. %开头

违反最左前缀原则

![image-20240726202500210](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726202500210.png)

范围查询右边的列，不能使用索引

![image-20240726202632471](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726202632471.png)

不要在索引列上进行运算操作，索引将失效

字符串不加单引号，索引失效（发生了类型的转换）

![image-20240726202753470](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726202753470.png)

%开头，模糊查询有可能会失效

![image-20240726202847560](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726202847560.png)

## 索引的基本原理

不断缩小想要获得数据的范围  筛选最终想要的结果。

将随机事件 变为 顺序事件，快速锁定数据。

![image-20210327165202668](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327165202668.png)

## 索引应用场景

```sql
alter table table_name add index(字段名) 创建索引

1. where : where WHERE 筛选字段进行查询时，如果 该字段建立索引，则查询效率更高
2. order by : 使用order by将查询结果按照某个字段进行排序时，如果该字段不建立索引，查询出的数据会使用外部排序，涉及磁盘io，效率低， 
	但如果建立索引，由于索引有序， 会按照索引顺序逐条读出数据
3. 索引覆盖
	查询的字段都建立过索引，引擎会直接在索引表中查询而不访问原始数据，尽可能在select后只写必要的查询字段，以增加索引覆盖的几率。
```



## MySQL索引的数据结构，各自优劣

与存储引擎有关，hash索引，b+树索引。

哈希索引： 哈希表，单条记录查询。

```
(1) hash 索引的实现 
    底层数据结构 = hash表
    通过hash值定位数据行，产生碰撞则采用拉链法解决。
(2) hash索引的缺点 
    1. 适用于等值查询。
       但hash索引无法排序，因此不适用于范围查询，不支持最左匹配原则。
    2. 大量重复的键值，减低效率、
```

btree索引：

**磁盘预读取**

```
磁盘读取以【磁盘块】为基本单位。
【磁盘预读取】：每次读取多个【物理连续】的磁盘块
B树利用磁盘预读取特性。在建立节点时，申请【物理连续】的一页空间。
【一页空间】 = 磁盘预读取的 多个磁盘块总和
从而 【实现一次磁盘IO读取一个节点】，减少磁盘IO次数
```

b+树：平衡的多叉树，从根节点到每个叶子节点的高度值不超过1，而且同层级的节点间有指针相互连接。从根节点到叶子节点的搜索效率高。且基于索引的顺序扫描，也可以通过叶子节点的双向指针快速搜索。

## 聚簇索引与非聚簇索引的区别

聚簇索引：数据和索引放到一块，主键一定是聚簇索引，B+树叶子结点保存整行数据，只有1个必须有

非聚簇索引（二级索引）：数据和索引分开存储，B+树叶子结点保存对应的主键，一般自己定义的索引，可以存在多个

![image-20240726200612028](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726200612028.png)

## 什么是回表查询

回表查询就是：通过二级索引找到对应的主键值，通过主键值找到聚簇索引中对应的整行数据（和聚簇索引和非聚簇索引有关）

## 什么是覆盖索引

指查询的时候用到了索引，返回的列必须在索引中全部能够找到
- 如果使用id查询，直接走聚集索引，一次索引扫描，返回整行数据，性能高
- 如果返回的列中没有创建索引，可能会触发回表查询，索引尽量避免select*

![image-20240726201313622](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726201313622.png)

## mysql超大分页怎么处理？

在数据量比较大时，limit分页查询，需要对数据进行排序，效率低：

解决方案：覆盖索引 + 子查询

![image-20240726201522826](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726201522826.png)

# 锁

事务隔离级别实现中，就需要锁来解决幻读问题。默认是可重复读级别，有幻读问题。

## 锁的类型

基于锁的属性分类：共享锁、排他锁

基于锁的粒度分类：行级锁InnoDB，表级锁MyIsam，页级锁，记录锁，间隙锁，临建锁。

基于锁的状态分类：意向共享锁，意向排他锁

### 共享锁Share lock

读锁，s锁：支持并发读。

一个事务为数据加上读锁后，其他事务只能对该数据加读锁，不能加写锁。

### 排他锁Exclusive lock

写锁，x锁

一个写锁会阻塞其他的读锁和写锁，只允许一个用户写入，防止其他用户读取正在写入的资源。

### 表锁

锁整个表，下一个事务访问该表时，需要等前一个事务释放锁才可以。

> 当索引失效时，行锁会升级为表锁。

特点：粒度大，易冲突。

### 行锁

锁某一行或多行。

特点：粒度小，不容易冲突，相比表锁支持的并发要高。

`select * from tab where id = 1 for update`

### 记录锁 record lock

是行锁的一种，记录锁锁住的范围只是表中的某一条记录。

加了记录锁后，可以避免重复读和脏读的问题。

### 页锁

锁粒度介于表锁和行锁之间，一次锁定相邻的一组记录。

特点：开销和加锁事件介于表锁和行锁之间；会出现死锁；并发度一般。

### 间隙锁 gap lock

属于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的**某一个区间**，当表的相邻id之间出现空隙则会形成一个区间，遵循左开右闭原则。

例如：数据有id = 1， 3，5，7四条数据，在查找1-7范围的数据，1-7都会被加上锁，2，4，6不在这些记录中，就是所谓的间隙。

间隙锁只会出现在RR的事务级别中，防止幻读问题。

### 临键锁 next-key-lock

属于行锁的一种，它是innodb的行锁默认算法：是**记录锁record lock和间隙锁gap lock的结合**，通过在index上加lock实现：

1. 如果index为唯一索引，降级为record lock。
2. 如果是普通索引，为next-key lock。
3. 如果没有index，则直接锁住全表，即表锁。

临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也锁住，且将相邻的下一个区间也锁住。意思是，加了next-key-lock后，返回区间内数据不允许被修改和插入。

临键锁的存在，使得Mysql在RR级别就可以解决脏读、重复读、幻读的问题。

### 悲观锁or乐观锁

乐观锁：并不会真正去锁某行的记录，通过版本号实现

被关锁：上面行锁、表锁都是悲观锁

# MySQL日志

## 常见日志有哪些

binlog、redolog、undolog、慢查询log

## 慢查询日志有什么用

记录执行时间超过指定阈值的查询语句，帮助识别性能较差的查询语句，从而进行优化

## binlog主要记录了什么

记录了对数据库进行更改的所有操作，包括数据修改、表结构变更等，用于数据恢复和复制

## redo log如何保证事务持久性

将事务的修改操作记录到日志中，然后在事务提交前将日志写入磁盘，从而保证事务的持久性

## 页修改之后为什么不直接刷盘

页修改之后不直接刷盘是因为为了提高性能，MySQL采用了脏页延迟刷盘策略，将脏页先写入到内存中的缓冲池，然后由后台线程定期将脏页刷入磁盘。

## binlog和redolog有什么区别

Binlog是MySQL的二进制日志，记录了对数据库进行更改的所有操作；而Redo log是InnoDB存储引擎的事务日志，记录了事务的修改操作

## undolog如何保证原子性

Undo log通过记录事务对数据的修改操作，可以在事务回滚时撤销事务对数据的修改，从而保证事务的原子性

# SQL优化

## 如何定位慢查询

慢查询出现的原因？聚合查询、多表查询、表数据量过大查询、深度分页查询

- 利用开源工具：Arthas、Prometheus、Skywalking，检测出哪个接口慢

- 利用MySQL自带的慢日志，设置2s，一旦sql超过2s就会记录到log中（调试阶段）

```
slow_query_log=1
long_query_time=2
```

**慢查询日志相关指令**

```sql
SHOW VARIABLES LIKE '%quer%'; -- 查看当前慢查询日志的开启情况
```

![image-20210328195709796](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210328195709796.png)

## 定位到了SQL，怎么分析呢？

> 分析SQL执行计划：explain 或者 desc
>
> - 通过key和key_len 检查是否命中了索引（索引本身是否存在失效的情况）
>
> - 通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描or全盘扫描
> - 通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引or修改返回字段来修复

执行计划就是sql的执行查询顺序，以及如何使用索引查询，返回的结果集的行数。

![image-20210327155730565](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327155730565.png)

重要的：

- possible_key：当前sql可能会使用到的索引
- key：当前sql实际命中的索引
- key_len：索引占用的大小
- Extra：额外的优化建议
- type：sql连接的类型，执行效率：all< index < range < ref < eq_ref < const < system **避免all和index**

![image-20240726195408559](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726195408559.png)

---

一、id 查询的顺序号，有几个select就显示几行，id的顺序是按select出现的顺序增长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行， id列的值为null最后执行。

二、select_type  SELECT关键字对应的查询类型（不包含UNION或子查询就是SIMPLE）

- SIMPLE：表示此查询不包含 UNION 查询或子查询

- PRIMARY：表示此查询是最外层的查询（包含子查询）

- SUBQUERY：子查询中的第一个 SELECT

- UNION：表示此查询是 UNION 的第二或随后的查询

- DEPENDENT UNION：UNION 中的第二个或后面的查询语句，取决于外面的查询

- UNION RESULT：UNION 的结果

- DEPENDENT SUBQUERY：子查询中的第一个 SELECT，取决于外面的查询。即子查询依赖于外层查询的结果。

- DERIVED：衍生，表示导出表的 SELECT（FROM 子句的子查询）

三、table：表名

四、partitions：匹配的分区信息

**五、type：优化sql的重要字段，也是判断sql性能和优化程度重要指标，他的取值类型范围：**

- **const**：通过索引一次命中，**匹配一行数据**。【主键||唯一】索引
- system：表中只有一行记录，相当于系统表、
- eq_ref：**唯一性索引扫描**，对于每个索引键，表中只有一条记录与之匹配。【主键||唯一】索引+ 【表联结情况】
- ref：非唯一性索引扫描，返回匹配某个值的所有。【可能重复】的【普通索引】+【表联结】
- range：只检索指定范围的行，使用一个索引来选择行，一般用于between，< , >。【索引】+【范围查询】
- index：只遍历索引树。
- all：**全表扫描**，这个类型的查询是性能最差的查询之一。

> 执行效率：all< index < range < ref < eq_ref < const < system **避免all和index**

六、possible_keys：它标识mysql在执行该sql语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。

七、**key**：此字段是**mysql在当前查询时所使用到的索引**，是possible_keys的子集。

八、key_len：查询优化器使用的索引的字节数，可以评估联合索引是否被完全使用，也是我们优化sql时，评估索引的重要指标。

九、ref：当使用索引列等值查询时，与索引列进行等值查询匹配的对象信息

十、rows：mysql查询优化器根据统计信息，**估算**该sql返回结果集需要扫描读取的行数。值越大，性能越差。

十一、filter：返回结果的行占需要读到的行rows的百分比，就是百分比越高，说明需要查询到数据越准确，百分比越小，说明查询到的数据量大，而结果集很少。

十二、extra：

- using filesort：标识mysql对结果集进行**外部排序**，不能通过索引顺序达到排序效果，一般有using filesort都**建议优化**去掉，因为这样的查询cpu资源消耗大，延时大。
- using index：**覆盖索引扫描**，标识查询在索引树种就可以查找所需要的数据，不用扫描表数据文件，往往说明性能不错。
- using temporary：查询有使用**临时表**，一般出现于排序，分组和夺表join的情况，查询效率不高，**建议优化**。
- using where：sql使用了**where**过滤，效率较高。

## 索引优化

帮助mysql高效获取数据的数据结构。数据库系统维护 B+树，帮助快速查找。

B+树和二叉树的比较

B+树和红黑树比较：

B+树和B树比较：磁盘读写代价更低+查询更稳定+便于扫库和区间查询

聚集索引和非聚集索引、覆盖索引、回表查询

索引创建原则

失效场景

## SQL优化经验

1. 表设计优化，参考阿里手册嵩山版，选择合适数值（int，tinyint，bigint）（char varchar）

   ![image-20240726203526372](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726203526372.png)

2. 索引优化

3. SQL语句优化

   ![image-20240726203219591](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726203219591.png)

4. 主从复制、读写分离

   ![image-20240726203506570](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726203506570.png)

5. 分库分表

# 主从同步

核心是 二进制日志 binlog，记录了所有的DDL和DML。

![image-20240726203506570](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240726203506570.png)

![image-20240727000041743](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240727000041743.png)

# 分库分表

海量数据存储

垂直分库分表

水平分库分表

# 其他知识点总结

## 简述关系型数据库与非关系型数据库

- **关系型数据库**（RDBMS）：就是建立在关系模型【二维表格模型】基础上的数据库，SQL 就是关系型数据库的查询语言。
  - 
- NoSQL 泛指非关系型数据库，包括了键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。

  - **键值型数据库**通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。优点： key作为唯一标识符，查找速度快。缺点： 无法像关系型数据库一样自由使用条件过滤，比如where。key-value典型的使用场景是作为内容缓存，Redis是最流行的键值型数据库。

  - **文档型数据库**：管理文档，在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录，MongoDB 是最流行的文档型数据库。
  - **搜索引擎**：搜索引擎的优势在于采用了全文搜索的技术，核心原理是“倒排索引”，Elasticsearch、Splunk 和 Solr。
  - **列式数据库**：相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限，典型案例：HBase。
  - **图形数据库**，利用了图这种数据结构存储了实体（对象）之间的关系。数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。

## SQL语句的执行

```
1. 应用服务器与数据库服务器建立一个连接，应用服务器发送SQL请求

2. 数据库进程拿到【sql请求】，通过【连接器】验证SQL语句是否具有【权限】

3. 【分析器】进行 词法分析和语法分析。 
    词法分析 提取SQL语句关键元素 ： SELECT 、 表名 、 查询条件等
    语法分析 判断SQL语句是否正确 ：判断关键词是否正确

4. 【优化器】生成SQL【执行计划】
    
5. 【执行器】按照执行计划， 将数据读取到内存并进行逻辑处理

6. 通过连接，将数据传输给应用服务器 

7. 断开连接
```

## 数据库三大范式

第一范式： 每个列不可分离。

第二范式：非主键完全依赖主键。

第三范式：非主键只依赖主键，不依赖非主键。

## 反范式

为什么需要反范式？

虽然范式可以避免数据冗余，减少数据库的空间，减轻维护数据完整性的麻烦。

但导致数据库业务涉及的表变多，并且可能需要将涉及的业务表进行多表连接查询，这样将导致性能变差，且不利于分库分表。

因此，出于性能优先的考量，可能在数据库的结构中需要使用反模式的设计，即**空间换取时间，采取数据冗余的方式避免表之间的关联查询**。

**需要谨慎使用反模式设计数据库**。一般情况下，尽可能使用范式化的数据库设计，因为范式化的数据库设计能让产品更加灵活，并且能在数据库层保持数据完整性。

## 大表优化的一些方法

1. 限定数据的范围：查询语句 通过查询条件限定数据范围。

2. 数据库主从同步，读写分离 ： 主库写数据， 从库读数据。【负载均衡+  数据备份+ 高可用】

   主从同步的实现：

   - 主库记录数据库的所有变更记录到binlog
   - binlog有变动时，发送给从节点。
   - 从节点IO线程接收binlog内容，写入relay log
   - 从节点sql线程读取relay log，重放。

3. 垂直分区：

   优点：一行记录的数据量变少，查询时IO次数减少。

   缺点：1、主键冗余2、 引起join操作。

4. 水平分区

   将行数据分组存储到不同的【库||表】中。

   缺点：

   1. 在查询时，通常需要多个表名+union操作。
   2. 跨库join性能很差。
   3. 跨库的事务支持，逻辑复杂度和性能代价大。

## 分库分表后出现的问题

```
        (1). 【跨节点】的 count，order by ， group by 等【聚合函数】逻辑复杂
        (2). 【跨库】的join 性能代价大
        (3). 【主键ID问题】 ：MySQL原先主键自增机制，跨库情况下，存在主键重复的问题
           1)  若采用 UUID作为主键， 则UUID主键占用内存过大
           2)  多个数据库采用 跨步自增
           3) ...
        (4) 【事务支持】
```

## 数据库调优！！优化！！！

### 目标是什么？

让数据库运行的更快，响应越快，吞吐量更大

- 微观反馈：用户的反馈，日志分析（数据库日志，操作系统日志）
- 宏观反馈：服务器资源使用监控（cpu、内存、io使用），数据库内部状态监控（是否sql堆积等）

### 调优方法

#### 1. 选择合适的DBMS

#### 2. 表设计优化

第三范式，适当进行反范式优化，表字段的数据类型选择

#### 3. 逻辑查询优化

采用sql语句等价变换的方式，对查询进行重写，数学基础是关系代数

sql查询重写包括：子查询优化、等价谓词重写、视图重写、条件简化、连接消除、嵌套连接消除等

#### 4. 物理查询优化

将逻辑查询执行计划编程物理操作符，为执行器提供执行准备

创建索引！！！

确定访问路径（单表、两张表、多表的连接）

#### 5. 加缓存

redis、memcached

#### 6. 库级优化

原则：通过切分的方式 提高 单一数据库服务器的性能

主从复制（master写、slave读）读写分离

垂直切分（分库分表） and 水平切分（大数据表拆分为 多个子表，表结构相同）

## SQL查询怎么优化？

是否有索引、是否命中索引、是否查询了多余字段、数据是否过多（分库分表）、机器性能

## mysql主从同步原理

![image-20210327144338887](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327144338887.png)

![image-20210327144617010](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327144617010.png)