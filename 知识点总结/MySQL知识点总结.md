[toc]



# 存储引擎MyISAM与InnoDB的区别

## MyISAM

不支持事务，但每次查询都是原子的。

支持表级锁，每次操作是对整个表加锁。

存储表的总行数，count速度很快。

拥有三个文件：索引文件、表结构文件、数据文件。

非聚簇索引：索引文件得数据域存储指向数据文件的指针，辅助索引与主索引基本一致，但辅助索引不用保证唯一性。

## InnoDB

支持ACID的事务，支持事务的四种隔离级别。

支持行级锁及外键约束：因此可以支持写并发。

不存储总行数。

一个InnoDB引擎存储在一个文件空间【共享表空间，表大小不受操作系统的控制，一个表可能分布在多个文件里】，也有可能为多个【设置为独立表空间，表大小受操作系统文件大小限制，一般为2G】受操作系统文件大小的限制。

主键索引采用聚集索引【索引的数据域存储数据文件本身】，辅助索引的数据域存储主键的值。因此从辅助索引查找数据，需要现通过辅助索引找到主键值，再访问辅助索引。最好使用自增主键，防止插入数据时，为维持B+树结构，文件大调整。

```
    1. 【是否支持行锁】
        MyISAM 仅支持表锁， InnoDB支持表锁和行锁
        
    2. 【是否支持事务】 
        MyISAM不支持事务，且不具备【崩溃恢复能力】。
        InnoDB 支持事务，提供回滚和崩溃恢复。
    
    3. 【是否支持外键】
        仅InnoDB支持外键 
    4. 【是否支持MVCC】
        仅InnoDB支持MVCC
    
    5. 【应用场景不同】
        MyISAM 适用 【Select】频繁，并发少
        InnoDB 适用 【Insert Delete Update】频繁，高并发

        因为 
        (1) MyISAM 仅缓存索引块，而InnoDB缓存 {索引+数据}
        (2) InnoDB 回表需要映射块，而MyISAM 直接映射数据地址
        (3) InnoDB 需要维护MVCC机制
        
    6.  MyISAM索引 和 InnoDB 索引 区别
        MyISAM 【索引】 叶子节点 = {key ， 行数据地址}
        
        InnoDB 【主键索引】 叶子节点 = {主键ID ， data数据}
        因此 InnoDB根据【主键】索引查询，不需要二次寻址，效率更高
        
        InnoDB 【二级索引】 叶子节点 = {key, 主键ID}
        如果实现索引覆盖，即 要查询列值 全部命中索引，则直接返回 非主键索引的内容
        如果未实现索引覆盖，则需要根据【主键ID】做回表
    
    7.  【存储结构不同】
        InnoDB 存储结构 = 索引和数据 集中存储
        MyISAM存储结构 = {表定义，MYD数据文件，MYI索引文件}
    
    8.  不带WHERE条件时，【count(*)效率不同 】
        MyISAM 自带计数器存储保存【总行数】，可直接返回结果
        InnoDB 扫描全表计算总行数
        
    
```

# 事务及隔离级别

## ACID特性

```
    1. Atomicity
        事务是不可分割的最小单元，事务内所有操作要么全部执行成功，要么全部失败回滚

    2. Isolation
        事务所作出的修改，在提交前，对于其他事务而言不可见
        
    3. Durability
        事务一旦提交，所作出的修改是永久的。
        
    4. Consistency
        系统从一个正确状态-->另一个正确状态
        
        
       【数据库】约束列值 不能小于0，则事务执行失败
       【应用层】约束 余额数据不能小于0，则应用层通过事务回滚保证约束
       
       没有约束，则事务执行成功，且保持了一致性。因为没有破坏约束。
       
     AID是数据库的特征，通过AID手段保证C这个最终目的。
```

## ACID如何保证

A原子性由undo log日志保证，记录了需要回滚的日志信息，事务回滚时撤销已经执行的sql。

C一致性由其他三大特性保证、程序代码需要保证业务上的一致性。

I隔离性由MVCC来保证。

D持久性由**内存+redolog**来保证，mysql修改数据同时再内存和redolog记录这次操作，宕机的时候可以从redolog恢复。

```
InnoDB redolog 写盘，InnoDB事务进入prepare状态

如果前面的prepare成功， binlog写盘，再继续将事务日志持久化到binlog，如果持久化成功，事务则进入commit状态（在redolog 里面写一个commit记录）

redolog的刷盘会在系统空闲时进行。
```

## 并发事务带来的问题

```
    1. 脏读 
        事务A 修改数据，但并未commit。而事务B读取该数据。 
    2. 丢失修改
        事务A 、B都读取同一个数据。事务A 、B先后修改数据，则 第一次修改操作丢失。
    3. 不可重复读
        事务A 共读取两次数据，而在这两次读取之间。事务B修改了数据。则事务A两次读取到的数据不同。
    4. 幻读 
        事务A 读取某数据不存在，事务B正好插入该条数据。事务A试图插入该数据发生冲突，就和产生幻觉一样。
```

幻读演示：

```sql
事务A
set autocommit = 0;
begin;
select * from t_user where id = 5; -- 没有数据

事务B
begin;
insert into t_user values(5, 'haha', 'haha');
commit;

事务A
insert into t_user values(5, 'hyh', 'hyh'); 
-- Duplicate entry '5' for key 't_user.PRIMARY'
select * from t_user where id = 5; -- 还是没有数据，但就是插不进去，跟鬼一样
```

## 事务隔离级别

查看事务隔离级别：

```sql
select @@transaction_isolation; 
show variables like 'transaction_isolation';
```

修改事务的隔离级别

```sql
set [session | global] transaction isolation level 
{READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE};
```

事务使用

```sql
begin;
select * from user;
commit || rollback;
```

查看有多少事务正在运行

```sql
select * from information_schema.innodb_trx;
```

```
    1. Read-Uncommitted 读取未提交
        无论事务是否提交，直接【读取主记录】 
        即并发问题 =【脏读】+【不可重复读】+【幻读】
    2. Read-committed 读取已提交
        【读取最新版本的快照】，快照是事务提交后产生，但可能存在同一事务两次读取的快照不同。
        即并发问题 = 【不可重复读】+【幻读】
    3. Repeatable 可重复读
        【读取指定版本快照】，则事务多次读取某数据行的结果一致，但读取到的数据可能并非最新数据 。
        即并发问题 = 【幻读】
    4. Serializable 可串行化 
        上表锁，读写相互阻塞。效率低下。
        无并发问题 
        
    InnoDB引擎默认实现 可重复读隔离级别  Oracle默认是读已提交
    
    四种隔离级别都是有存在的意义的，根据具体场景选择。
```

## MVCC

```
【概念】：
 多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链。

【目的】 ： 
    MVCC是行锁的变种，它想要尽可能地避免加锁操作，实现【非阻塞】读。从而提高处理并发事务的性能

【MVCC 实现的隔离级别】
    MVCC仅 Read Committed & REPEATABLE READ 两种隔离级别
    READ UNCOMMITTED 总是【读取最新】数据行 ，与MVCC的版本快照机制不符
    SERIALIZABLE 则 对读取的【数据行】都加锁 ，与MVCC 尽可能避免加锁的原则不符
    
【undolog】 记录数据行的某个历史版本，undolog以链表形式存在

RC 是读取 最新版本的 undolog
RR 是读取 某一指定老版本的undolog

【三个字段】
row_id: 隐含的自增id，数据库默认为该行记录生成的唯一隐式主键
trx_id: 用来存储每次对某条聚簇索引记录进行修改的时候的事务id。
roll_pointer: 回滚指针，配合undolog，指向上一版本
```

![image-20210327151321694](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327151321694.png)

## mysql执行计划怎么看？

执行计划就是sql的执行查询顺序，以及如何使用索引查询，返回的结果集的行数。

![image-20210327155730565](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327155730565.png)

一、id 查询的顺序号，有几个select就显示几行，id的顺序是按select出现的顺序增长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行， id列的值为null最后执行。

二、select_type 查询中每个select子句的类型

![image-20210327155925564](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327155925564.png)

三、table：标识该语句查询的表

四、type：优化sql的重要字段，也是判断sql性能和优化程度重要指标，他的取值类型范围：

- const：通过索引一次命中，**匹配一行数据**。【主键||唯一】索引
- system：表中只有一行记录，相当于系统表、
- eq_ref：**唯一性索引扫描**，对于每个索引键，表中只有一条记录与之匹配。【主键||唯一】索引+ 【表联结情况】
- ref：非唯一性索引扫描，返回匹配某个值的所有。【可能重复】的【普通索引】+【表联结】
- range：只检索指定范围的行，使用一个索引来选择行，一般用于between，< , >。【索引】+【范围查询】
- index：只遍历索引树。
- all：**全表扫描**，这个类型的查询是性能最差的查询之一。

> 执行效率：all< index < range < ref < eq_ref < const < system 避免all和index

五、possible_keys：它标识mysql在执行该sql语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。

六、**key**：此字段是**mysql在当前查询时所使用到的索引**，是possible_keys的子集。

七、key_len：查询优化器使用的索引的字节数，可以评估联合索引是否被完全使用，也是我们优化sql时，评估索引的重要指标。

八、ref

九、rows：mysql查询优化器根据统计信息，估算该sql返回结果集需要扫描读取的行数。值越大，性能越差。

十、filter：返回结果的行占需要读到的行rows的百分比，就是百分比越高，说明需要查询到数据越准确，百分比越小，说明查询到的数据量大，而结果集很少。

十一、extra：

- using filesort：标识mysql对结果集进行**外部排序**，不能通过索引顺序达到排序效果，一般有using filesort都**建议优化**去掉，因为这样的查询cpu资源消耗大，延时大。
- using index：**覆盖索引扫描**，标识查询在索引树种就可以查找所需要的数据，不用扫描表数据文件，往往说明性能不错。
- using temporary：查询有使用**临时表**，一般出现于排序，分组和夺表join的情况，查询效率不高，**建议优化**。
- using where：sql使用了**where**过滤，效率较高。

# 索引

## MySQL类型

### 索引类型

普通索引：允许被索引的数据列包含重复的值。

唯一索引：记录唯一性。

主键索引：特殊的唯一索引，一张表只能定义一个主键索引，主键用于唯一标识一条记录，使用primary key创建。

联合索引：索引可以覆盖多个列，index(col1, col2)索引。

全文索引：倒排索引，极大提升检索效率，解决判断字段是否包含的问题。alter table tb_user add fulltext(col)

### 对性能的影响

1. 极大提高数据的查询速度。

2. 使用索引，在查询过程种，使用优化隐藏器，提高性能。
3. 会降低插入、删除、更新表的速度，因为在执行写操作时，还需要操作索引文件。
4. 索引需要占物理空间，除了数据表占数据空间之外，每个索引还有占一定的物理空间，如果要建立聚簇索引，那么需要空间就会更大，如果非聚簇索引很多，一旦聚簇索引改变，非聚簇索引也会跟着变。

## B树和B+树的区别

```
1.  Mysql根据【磁盘IO次数】衡量查询效率，而【B+树磁盘IO次数更少】

    因为 B+树中【 非叶节点 = { 指针+key } 】
    而B树中 【非叶节点 = { 指针+ key + data数据 }】,
    每个节点(即每一页) 存储空间有限，B树节点存储的key较少，出度较小
    因此B树的节点较多(key总量固定)
    导致B树深度较大，磁盘IO次数多。
    
2.  B+树叶子节点通过指针连接，便于【区间访问】
```

**B树**

![1584071014(1)](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1584071014(1).png)

**B+树**

![1584071033(1)](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1584071033(1).png)

每个磁盘块包含蓝色的指针和几个紫色数据项。

但这里的紫色数据项只是标识指针的范围，即p1 标识小于28的磁盘块，p2标识大于28的磁盘块。

非叶子节点并不存储真实的数据，只存储指引搜索方向的指针。

真实的数据在叶子节点。

> 3层的b+树可以表示上百万的数据，需要三次IO,性能提升巨大。

## 为什么是B+树，而不是红黑树？

B+树磁盘IO次数更少。

1. 红黑树的深度往往较大，磁盘IO次数和树高度成正比。
2. B树利用磁盘预读取特性，在建立节点时，申请物理连续的一页空间【磁盘预读取的多个磁盘款的总和】，从而实现一次磁盘IO读取一个节点，减少磁盘IO次数。 但红黑树逻辑较近的节点，其物理距离可能较远，无法利用磁盘预读取的特性。

## 索引的设计原则

![image-20210327163138151](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327163138151.png)

## 索引的基本原理

不断缩小想要获得数据的范围  筛选最终想要的结果。

将随机事件 变为 顺序事件，快速锁定数据。

![image-20210327165202668](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327165202668.png)

## 索引应用场景

```sql
alter table table_name add index(字段名) 创建索引

1. where : where WHERE 筛选字段进行查询时，如果 该字段建立索引，则查询效率更高
2. order by : 使用order by将查询结果按照某个字段进行排序时，如果该字段不建立索引，查询出的数据会使用外部排序，涉及磁盘io，效率低， 
	但如果建立索引，由于索引有序， 会按照索引顺序逐条读出数据
3. 索引覆盖
	查询的字段都建立过索引，引擎会直接在索引表中查询而不访问原始数据，尽可能在select后只写必要的查询字段，以增加索引覆盖的几率。
```



## MySQL索引的数据结构，各自优劣

与存储引擎有关，hash索引，b+树索引。

哈希索引： 哈希表，单条记录查询。

```
(1) hash 索引的实现 
    底层数据结构 = hash表
    通过hash值定位数据行，产生碰撞则采用拉链法解决。
(2) hash索引的缺点 
    1. 适用于等值查询。
       但hash索引无法排序，因此不适用于范围查询，不支持最左匹配原则。
    2. 大量重复的键值，减低效率、
```

btree索引：

**磁盘预读取**

```
磁盘读取以【磁盘块】为基本单位。
【磁盘预读取】：每次读取多个【物理连续】的磁盘块
B树利用磁盘预读取特性。在建立节点时，申请【物理连续】的一页空间。
【一页空间】 = 磁盘预读取的 多个磁盘块总和
从而 【实现一次磁盘IO读取一个节点】，减少磁盘IO次数
```

b+树：平衡的多叉树，从根节点到每个叶子节点的高度值不超过1，而且同层级的节点间有指针相互连接。从根节点到叶子节点的搜索效率高。且基于索引的顺序扫描，也可以通过叶子节点的双向指针快速搜索。

## 聚簇索引与非聚簇索引的区别

![image-20210327164817596](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327164817596.png)

# 锁

## 锁的类型

基于锁的属性分类：共享锁、排他锁

基于锁的粒度分类：行级锁InnoDB，表级锁MyIsam，页级锁，记录锁，间隙锁，临建锁。

基于锁的状态分类：意向共享锁，意向排他锁

## 共享锁Share lock

读锁，s锁：支持并发读。

一个事务为数据加上读锁后，其他事务只能对该数据加读锁，不能加写锁。

## 排他锁Exclusive lock

写锁，x锁

一个写锁会阻塞其他的读锁和写锁，只允许一个用户写入，防止其他用户读取正在写入的资源。

## 表锁

锁整个表，下一个事务访问该表时，需要等前一个事务释放锁才可以。

> 当索引失效时，行锁会升级为表锁。

特点：粒度大，易冲突。

## 行锁

锁某一行或多行。

特点：粒度小，不容易冲突，相比表锁支持的并发要高。

`select * from tab where id = 1 for update`

## 记录锁 record lock

是行锁的一种，记录锁锁住的范围只是表中的某一条记录。

加了记录锁后，可以避免重复读和脏读的问题。

## 页锁

锁粒度介于表锁和行锁之间，一次锁定相邻的一组记录。

特点：开销和加锁事件介于表锁和行锁之间；会出现死锁；并发度一般。

## 间隙锁 gap lock

属于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的**某一个区间**，当表的相邻id之间出现空隙则会形成一个区间，遵循左开右闭原则。

例如：数据有id = 1， 3，5，7四条数据，在查找1-7范围的数据，1-7都会被加上锁，2，4，6不在这些记录中，就是所谓的间隙。

间隙锁只会出现在RR的事务级别中，防止幻读问题。

## 临键锁 next-key-lock

属于行锁的一种，它是innodb的行锁默认算法：是**记录锁record lock和间隙锁gap lock的结合**，通过在index上加lock实现：

1. 如果index为唯一索引，降级为record lock。
2. 如果是普通索引，为next-key lock。
3. 如果没有index，则直接锁住全表，即表锁。

临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也锁住，且将相邻的下一个区间也锁住。意思是，加了next-key-lock后，返回区间内数据不允许被修改和插入。

临键锁的存在，使得Mysql在RR级别就可以解决脏读、重复读、幻读的问题。

## 悲观锁

在整个数据处理

## mysql主从同步原理

![image-20210327144338887](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327144338887.png)

![image-20210327144617010](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210327144617010.png)



# 其他知识点总结

## 简述关系型数据库与非关系型数据库

- **关系型数据库**（RDBMS）：就是建立在关系模型【二维表格模型】基础上的数据库，SQL 就是关系型数据库的查询语言。
  - 
- NoSQL 泛指非关系型数据库，包括了键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。

  - **键值型数据库**通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。优点： key作为唯一标识符，查找速度快。缺点： 无法像关系型数据库一样自由使用条件过滤，比如where。key-value典型的使用场景是作为内容缓存，Redis是最流行的键值型数据库。

  - **文档型数据库**：管理文档，在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录，MongoDB 是最流行的文档型数据库。
  - **搜索引擎**：搜索引擎的优势在于采用了全文搜索的技术，核心原理是“倒排索引”，Elasticsearch、Splunk 和 Solr。
  - **列式数据库**：相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限，典型案例：HBase。
  - **图形数据库**，利用了图这种数据结构存储了实体（对象）之间的关系。数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。

## SQL语句的执行

```
1. 应用服务器与数据库服务器建立一个连接，应用服务器发送SQL请求

2. 数据库进程拿到【sql请求】，通过【连接器】验证SQL语句是否具有【权限】

3. 【分析器】进行 词法分析和语法分析。 
    词法分析 提取SQL语句关键元素 ： SELECT 、 表名 、 查询条件等
    语法分析 判断SQL语句是否正确 ：判断关键词是否正确

4. 【优化器】生成SQL【执行计划】
    
5. 【执行器】按照执行计划， 将数据读取到内存并进行逻辑处理

6. 通过连接，将数据传输给应用服务器 

7. 断开连接
```

## 数据库三大范式

第一范式： 每个列不可分离。

第二范式：非主键完全依赖主键。

第三范式：非主键只依赖主键，不依赖非主键。

## 反范式

为什么需要反范式？

虽然范式可以避免数据冗余，减少数据库的空间，减轻维护数据完整性的麻烦。

但导致数据库业务涉及的表变多，并且可能需要将涉及的业务表进行多表连接查询，这样将导致性能变差，且不利于分库分表。

因此，出于性能优先的考量，可能在数据库的结构中需要使用反模式的设计，即**空间换取时间，采取数据冗余的方式避免表之间的关联查询**。

**需要谨慎使用反模式设计数据库**。一般情况下，尽可能使用范式化的数据库设计，因为范式化的数据库设计能让产品更加灵活，并且能在数据库层保持数据完整性。

## 大表优化的一些方法

1. 限定数据的范围：查询语句 通过查询条件限定数据范围。

2. 数据库主从同步，读写分离 ： 主库写数据， 从库读数据。【负载均衡+  数据备份+ 高可用】

   主从同步的实现：

   - 主库记录数据库的所有变更记录到binlog
   - binlog有变动时，发送给从节点。
   - 从节点IO线程接收binlog内容，写入relay log
   - 从节点sql线程读取relay log，重放。

3. 垂直分区：

   优点：一行记录的数据量变少，查询时IO次数减少。

   缺点：1、主键冗余2、 引起join操作。

4. 水平分区

   将行数据分组存储到不同的【库||表】中。

   缺点：

   1. 在查询时，通常需要多个表名+union操作。
   2. 跨库join性能很差。
   3. 跨库的事务支持，逻辑复杂度和性能代价大。

## 分库分表后出现的问题

```
        (1). 【跨节点】的 count，order by ， group by 等【聚合函数】逻辑复杂
        (2). 【跨库】的join 性能代价大
        (3). 【主键ID问题】 ：MySQL原先主键自增机制，跨库情况下，存在主键重复的问题
           1)  若采用 UUID作为主键， 则UUID主键占用内存过大
           2)  多个数据库采用 跨步自增
           3) ...
        (4) 【事务支持】
```

## SQL优化

### where优化

1. 全表扫描：where， order by涉及的列上建立索引。
2. where条件中避免使用判断：`is null, !=, or, in`，这些条件会导致全表扫描。
3. 避免运行时解析的变量：避免左侧**函数调用**或算数计算。

## 慢查询的相关指令

**慢查询日志相关指令**

```sql
SHOW VARIABLES LIKE '%quer%'; -- 查看当前慢查询日志的开启情况
```

![image-20210328195709796](img/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20210328195709796.png)