[toc]

# URL和URI的区别

- `URL(Uniform Resource Location) `是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。
- `URI(Uniform Resource Identifier) `是统一资源标志符，可以唯一标识一个资源。

# 浏览器输入URL的过程

> DNS解析 + TCP连接 + HTTP请求发送 + 服务器处理请求 + 返回HTTP报文 + 浏览器渲染
>
> 第1步：用户在浏览器输入url并回车。首先要做的是将url转换为IP地址。从url到IP地址的映射通常存储在缓存中，因此浏览器会在多层缓存中查找IP地址：浏览器缓存、操作系统缓存、本地缓存和ISP缓存。如果浏览器在缓存中找不到映射，就会请求DNS解析器进行解析。
>
> 第2步：如果在任何缓存中都找不到IP地址，浏览器就会转到DNS服务器进行递归DNS查找，直到找到IP地址为止。
>
> 第3步：有了服务器的IP地址，浏览器就会向服务器发送HTTP请求。为了安全访问服务器资源，我们应始终使用HTTPS。浏览器首先通过TCP三次握手与服务器建立TCP连接。然后向客户端发送公钥。客户端使用公钥加密会话密钥并发送给服务器。服务器使用私钥解密会话密钥。然后，客户端和服务端就可以使用会话密钥来交换加密数据，进行通信。
>
> 第4步：服务器处理请求并发回响应。相应成功时，状态代码为200。响应包含3个部分：HTML、CSS和Javascript。浏览器会解析HTML生成DOM树、解析CSS生成CSSOM树。然后将DOM树和CSSOM树合并为渲染树，渲染内容并返回给用户。

DNS：浏览器查找域名DNS的IP地址，浏览器缓存、路由器缓存、DNS缓存

TCP：三次握手

HTTP：加密，连接，发送请求

![1703562606828](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1703562606828.png)

# HTTP和HTTPS的区别

| HTTP                               | HTTPS                                  |
| ---------------------------------- | -------------------------------------- |
| 默认端口80                         | 默认端口443                            |
| POST明文传输、数据未加密、安全性差 | 密钥交换、签名算法、对称加密、摘要算法 |
| 响应速度快，消耗资源少             | 响应速度较慢、消耗资源多（CA证书等）   |

HTTP的默认端口是80 ，而HTTPS的默认端口为443。

HTTP在地址栏上的协议以http://开头，而HTTPS以https://开头。

HTTP是未经安全加密的协议，传输过程容易被攻击者监听，数据容易被窃取，发送方和接收方容易被伪造。而HTTPS是安全的协议，通过**密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法**能够解决上面的这些问题。

HTTP是应用层协议，HTTPS是HTTP+TLS/SSL，在HTTP的基础上披了一层SSL，多了secure安全性的概念，并非新的应用层协议。

# HTTPS链接建立的过程

1. C给S发一个请求
2. S给C发一个SSL证书，内容有：CA的发布机构、有效期、所有者、签名、**公钥**
3. C对**公钥**进行真伪校验，为真则用： 公钥对称加密
4. S用**私钥**揭秘，并使用对称密钥 加密 确认信息 给C
5. 连接建立后，C和S使用对称密钥进行信息传输

![image](img/计算机网络知识点总结/1584608569(1).png)

# 对称加密和非对称加密

```
(1)    【对称加密】： 密钥只有一个，加密解密使用同个密码。【速度快】
            【优点】： 速度快
            【缺点】 ： 无法确保【消息来源】，存在自己发自己的情况
            【算法】：DES AES
            
(2)    【非对称加密】： 密钥分 公钥、私钥(本人保管)。
            (公钥加密内容 使用私钥解密，私钥加密内容，使用公钥解密)。
            【举例】： A 发送邮件给B ， 若邮件使用A的私钥加密，则确保(确保邮件来源)。 若邮件使用B的公钥加密，则确保邮件去处。
            【优点】： 确保【消息来源】 || 【消息去处】 【二者按需取一】
            【缺点】： 速度慢
            【算法】：RSA、DSA
(3)     【数字签名】：
            数字签名 = 对消息的hash值使用私钥加密。
            数字签名添加在消息尾部
            【优点】：确保 【消息来源】 和 【消息未被修改】。
            【缺点】：C修改B电脑中的A公钥，C冒充A发送数据给B，B无法察觉。
(4)     【数字证书】：
            数字证书 = 将A的公钥交由第三方CA(Certificate Authority)的私钥加密
            数字证书 添加在 消息尾部。避免B电脑中A公钥被替换。
```

# HTTP1.0，1.1，2.0，3.0的区别

![http-3-implementation](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/http-3-implementation.png)

**HTTP 1.0**

- 只提供了最基本的认证，用户名和密码还未经加密，很容易受到窥探。
- **短连接**，每次发送数据都会经过TCP的三次握手和四次挥手，效率低。
- 只使用header中的If-Modified-Since和Expires作为缓存失效的标准。
- 不支持断点续传，每次都会传送全部的页面和数据。
- 认为每台计算机只能绑定一个IP，所以请求消息中的URL并没有传递主机名。

**HTTP 1.1**

- 使用摘要算法进行身份验证。
- **默认使用长连接**，一次建立，中间可以传输多次数据，之后只需断开一次连接即可。长连接的连接时长可以通过请求头中的keep-alive来设置。
- **缓存处理**，新增了E-tag，If-Unmodified-Since，If-Match，If-None-Match等缓存控制标头来控制缓存失效。
- 支持**断点续传**，通过使用请求头中的Range实现。
- 使用虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。

**HTTP 2.0**

- **头部压缩**：由于 HTTP 1.1 经常会出现 **User-Agent、Cookie、Accept、Server、Range** 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 `HPACK` 算法进行压缩。
- **二进制格式**：HTTP 2.0 使用了更加靠近 TCP/IP 的二进制格式，而抛弃了 ASCII 码，提升了解析效率。
- **强化安全**：由于安全已经成为重中之重，所以 HTTP2.0 一般都跑在 HTTPS 上。
- **多路复用**：即每一个请求都是是用作连接共享。一个请求对应一个id，这样一个连接上可以有多个请求。

**HTTP 3.0**

- **传输协议**：HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） **协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟**。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。

- **连接建立**：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）**连接建立仅需 0-RTT 或者 1-RTT**。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。

  **队头阻塞**：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了**队头阻塞**（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是**多路复用+轮询**）。

  **错误恢复**：HTTP/3.0 具有更好的**错误恢复机制**，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。

  **安全性**：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0 使用 TLS 协议进行加密，而 **HTTP/3.0 基于 QUIC 协议**，包含了内置的加密和身份验证机制，可以提供更强的安全性。

# HTTP报文结构

一个HTTP请求报文由请求行（request line）、请求头部（request header）、空行和请求数据4个部分构成。

HTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。

# 常见HTTP状态码

| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 1xx    | 表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理流程 |
|  2xx | 表示成功接收请求并已完成整个处理流程，200 OK |
| 3xx | 浏览器需要执行特殊的处理以正确处理请求，302临时性重定向 |
| 4xx | 表示客户端发生了错误， 400Bad Request， 403Forbidden，404 NOT FOUND |
| 5xx | 表示服务器端出现了错误，500 |

# 重定向和转发的区别

重定向：redirect，地址栏发生变化，可以访问其他站点（服务器）的资源，两次请求

转发：forward，地址栏路径不变，只能访问当前服务器下的，一次请求，可以request共享数据

# HTTP请求有哪些

![image-20240724145059031](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240724145059031.png)

# GET和POST的方法区别

> get是幂等的
>
> ![image-20240724145152691](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240724145152691.png)

- GET在浏览器回退是无害的，而POST会再次提交请求
- GET请求会被浏览器主动cache,而POST不会，除非手动设置
- GET请求只能进行URL编码，而POST支持多种编码
- GET请求参数会被完整保留在浏览器历史记录中，而POST中的参数不会被保留
- GET请求在URL中传送参数是有大小限制的，不能大于2KB,而POST可以说没有
- GET只接受ASCII字符，而POST没有限制
- GET参数直接暴露在URL上，而POST将数据放在request body中

# HTTP协议本身是无状态的，如何保存用户的状态

HTTP 是一种不保存状态，即无状态（stateless）协议，不对请求和响应之间的通信状态进行保存。

可以使用session机制，在服务端记录用户的状态。

> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。

# Cookie和Session的区别

> 都是跟踪浏览器用户身份的会话方式，区别：
>
> 1、保存位置（客户端or服务端）
>
> 2. 安全性（session更安全，cookie在本地容易被偷）
> 3. 数据类型（cookie用户信息，session记录用户状态）

Cookie用于在客户端记录用户的状态，用户可以通过浏览器禁用Cookie。

而**Session通过在服务端记录用户的状态，不依赖于浏览器**，可以保存在集群、数据库、文件中。

> session存数据库的话，量可能会很大，且session有过期时间，存数据库并不太合适。
>
> 存内存的话，现在程序大多分布式部署，得想办法让同一个session得请求到相同的服务器才行。
>
> 建议使用redis，redis单线程，不存在线程安全问题。
>
> jwt ： [http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

Session较Cookie存储安全性更高，如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，**如果浏览器禁用了 cookie ，同时 session 也会失效**（但是可以通过其它方式实现，比如**在 url 中传递 session_id**）。

# （*）TCP/IP模型与OSI模型

> OSI七层：物理、数据链路、网络、传输、会话、表示、应用
>
> TCP/IP五层：物理、数据链路、网络、传输、应用

![6](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/6.png)

TCP/IP模型有时也分为四层：物理层和数据链路层合并表示为网络接口层。

应用层：应用进程间**通信数据** 的处理。

传输层：实现两台主机间**数据传输**。

网络层：两台主机通信，会经过多段**数据链路**。

数据链路层：确保一段链路上的数据传输。

物理层：实现两个节点间比特流的透明传输。

# 常见网络服务分层

> 应用层：**DNS**、SMTP、**HTTP**、FTP、**SSL**
>
> **传输层：TCP、UDP**
>
> 网络层：IP、ICMP、路由器、防火墙
>
> 数据链路层：网卡、网桥、交换机
>
> 物理层：中继器、集线器

**应用层**

1. DNS：域名->地址，多个主机可以映射为一个IP地址，一台主机映射唯一的MAC地址。
2. HTTP：实现客户端向服务端请求资源，服务端向客户端发送资源。
3. FTP：文件传输协议
4. STMP：邮件传输协议
5. SSL：加密套接字协议

**传输层**

1. TCP：面向连接，可靠，一对一全双工，应用于文件传输、重要状态更新。HTTP、FTP、SMTP基于TCP。
2. UDP：不面向连接，不可靠，一对多，应用于视频传输，实时通信，DNS基于UDP，调用频繁，建立连接开销较大。

**网络层**

ARP: IP => MAC

IP：主机间通信。

# （*）TCP与UDP的区别

> 都是传输层的协议
>
> 区别：是否**面向连接**（三次握手+四次挥手），是否**可靠**（数据完整【序号+确认机制】、拥塞控制【滑动窗口】，数据重传，有序交付），传输效率、几对几，面向对象，首部开销，**使用场景**（一个注重实时，一个注重可靠）
>
> | 类型 | 特点                                                         | 性能 | 首部字节 | 场景       |
> | ---- | ------------------------------------------------------------ | ---- | -------- | ---------- |
> | TCP  | 面向连接（握手 + 挥手）<br />可靠（错误重传、拥塞控制、错误校验和）<br />字节流、点到点 | 慢   | 20-60    | 文件、邮件 |
> | UDP  | 无连接、不可靠、数据报文段、可以多对多                       | 快   | 8        | 语音、视频 |
>
> 基于TCP的协议：HTTP（3.0之后改用 **基于 UDP 的 QUIC 协议**）、HTTPS、FTP、SMTP、SSH，基于UDP的：RIP，DNS，SNMP，DHCP，
>
> TCP首部：源和目标端口号、序号、确认序号、长度、标志字段、窗口大小、校验和等
>
> UDP首部：源和目标端口号、长度、校验和
>
> 理解记忆：序号、确认序号、标志、窗口、校验和等是确保tcp的可靠、有序的

TCP和UDP都是传输层的协议。

**连接方面**

TCP**面向连接**，发送数据前两端必须建立连接【三次握手】。

UCP是无连接的，发送数据之前不需要建立连接。

**安全方面**

TCP提供**可靠**的服务通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。

- 支持错误重传机制。
- 支持拥塞控制，能够在网络拥堵的情况下延迟发送。
- 提供错误校验和，甄别有害的数据包， 并进行错误恢复。

UDP尽最大努力交付，即**不保证可靠交付**。

**传输效率**

TCP传输效率相对较低。

UDP传输效率高，适用于对高速传输和实时性有较高的通信或广播通信。

**连接对象数量**

TCP连接**只能是点到点**、一对一的。

UDP支持一对一，一对多，多对一和多对多的交互通信。

**面向的对象**

UDP面向报文，对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。

TCP面向字节流，在不保留报文边界的情况下以字节流方式进行传输。

**首部开销**

TCP首部开销大，最小20字节，最大60字节。

UDP首部开销小，仅8字节。

**适用场景**

TCP：适用于需要可靠传输的应用，如文件传输。

UDP：适用于实时应用：视频会议，直播等。

# TCP协议是如何保证可靠传输的？

## 数据分包

为什么？保证有序，接收端按照包的序号排序 + 去重

怎么做？数据 分为多个数据包，每一个包有一个编号

## 校验和

为什么？检测数据在传输过程中的任何变化

怎么做？在首部确定，端到端校验和，如果有差错，就丢弃这个包，不确认

## 流量控制

为什么？防止接收端接收能力不足

怎么做？滑动窗口实现， 可变大小的滑动窗口协议，

## 拥塞控制

为什么？防止 过多的数据 注入网络中，避免网络中路由器、链路过载

怎么做？拥塞窗口实现，窗口大小分为几种情况改变：慢开始、拥塞避免、快重传、快恢复，TCP拥护一个拥塞窗口，该窗口随着网络拥塞程度动态变化，通过慢开始，拥塞避免等算法减少网络拥塞的发生。

1. **慢开始**：拥塞窗口大小cwbd < 慢开始阈值， 每经过一轮传播，cwnd加倍
2. 拥塞避免 ： 拥塞窗口大小cwbd > 慢开始阈值, 每经过一轮传播 拥塞窗口+1
3. **快重传**：接收端收到顺序错误的报文段后，向发送端发送重复的ACK报文，此时**发送端根据重复的ACK报文判断传输失败，而不是根据 超时判断发送失败**，避免超时等待。
4. 快恢复：慢开始阈值 = 初始拥塞窗口 = 旧拥塞窗口的一半。

## ARQ协议

为什么？自动重传，实现可靠传输

怎么做？等待停止和GO_BACK_N，每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

## 超时重传

为什么？在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。

怎么做？基于计时器的重传，当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

# TCP粘包原因和解决方法

TCP粘包是什么？发送方发送的若干包数据 到 接收方接收时粘成一包

有两方面的原因：发送方、接收方

发送方：tcp默认使用Nagle算法，减少网络中报文段的数量，收集多个小分组，在一个确认到来时一起发送，导致发送方可能会出现粘包问题

> Nagle算法的基本原理是：当一个TCP连接上有数据要发送时，并不立即发送出去，而是等待一小段时间（通常是由一个RTT，即往返时延来估计），看看是否有更多的数据要发送。如果在这段时间内有额外的数据产生，那么这些数据就会被组装成一个更大的报文一起发送。这样可以减少网络中由于过多的小包而引起的拥塞。

接收方：tcp将接收到的数据包保存在接收缓存里，如果tcp接收数据包到缓存的速度 > 应用程序从缓存中读取数据包的速度，多个包被缓存，应用程序就可能读到多个首尾相连粘到一起的包

总结：产生问题的原因，本质就是 接收方无法分辨消息和消息的边界

如何解决：给出方案确定边界

1. 发送定长包
2. 包尾加上`\r\n`标记。FTP就是这么做的，但是问题如果正文中也有`\r\n`会被错认
3. 包头加上包体长度。接收时，先确认包长度，再接收

# ARQ自动重传请求



# TCP报文结构及含义

![tcp](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/tcp.jpg)

**源端口和目的端口**：唯一确定一条TCP连接，TCP在发送数据前必须在彼此间建立连接，意思是：双方需要保存对方的信息。

**序列号seq**：占4个字节，用于标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生，给字节编上序号后，就给每一个报文段指派一个序号；**序列号seq就是这个报文段中的第一个字节的数据编号**，确保TCP传输有序。

**确认号ack**：占4个字节，**期待收到对方下一个报文段的第一个数据字节的序号**；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此**当前报文段最后一个字节的编号+1即为确认号**。

**确认ACK**：占1位，**仅当ACK=1时，确认号字段才有效**。ACK=0时，确认号无效。

**同步SYN**：连接建立时用于**同步序号**。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。**SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0**。

**终止FIN**：用来**释放一个连接**。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

**其他标志位的含义**：

![xuhao](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/xuhao.png)

# （*）TCP三次握手与四次挥手

> TCP协议是传输层协议，负责数据的可靠传输。
>
> 为什么？三次握手和四次挥手都是保证可靠连接的
>
> 是什么？
>
> - 三次握手：确保相互都知道 自己 收发正常
>   - C 给 S一个syn
>   - S收到syn之后，给C一个syn-ack（表示：S收到了C的请求， 确认了C可以发，S可以收）
>   - C收到syn-ack之后，给S一个ack（表示：C收到了S的确认，确认了S可以发，可以收，C可以发，可以收）
>
> - 四次挥手：
>   - C 给 S一个fin
>   - S收到fin之后，给C一个ack（表示S收到C的断开连接请求，**但是不会立即断开，可能还有数据在处理**）
>   - S处理完了之后，向C发送一个fin（表示S现在也可以断开了）
>   - C收到之后，给S一个ack（表示C也断开了，这里需要注意，**C会等待2个msl之后才断开，防止最后一个ack发送失败**）
>
> 为什么握手要三次，两次不行么？
>
> - 两次只能保证 单向连接是通的， 如果只有两次握手，至多只有连接发起方的起始序号可以被确认，另一方选择的序列号得不到确认
>
> 为什么挥手要四次，握手只要三次？
>
> - 握手的时候 S给C syn-ack 可以表示S的接收 和 C的发送都正常
> - 而挥手的时候，S收到fin也不会立即断开，而是先给一个ack，因为还会有数据继续处理
>
> CLOSEWAIT是等待关闭状态，TIMEWAIT是为了解决网络丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接

## 三次握手

![sanciwoshou](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/sanciwoshou.png)

1. 第一次握手：客户端发送初始序号seq = x和SYN=1的请求标志。此时**服务器得知客户端发送正常，自己接收正常**。
2. 第二次握手：服务器发送请求标志SYN=1,确认标志ACK=1，自己的序号seq=y，发送客户端的确认信号x+1。**客户端知道自己发送、接收正常，服务器接收、发送正常**。
3. 第三次握手：客户端发送确认信号ACK=1，发送自己的序号seq=x+1，发送对方的确认号ACK=y+1。**服务器知道客户端发送、接收正常，自己接收、发送也正常**。

## 四次挥手

![sicihuishou](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/sicihuishou.png)

第一次挥手：客户端发出释放FIN=1，自己序列号seq=u，进入FIN-WAIT-1状态，是客户端的请求断开。

第二次挥手：服务器收到客户端的请求后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态，服务器确认客户端的断开请求。

> 期间存在 服务端向客户端发送数据。

第三次挥手：客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态），服务器请求断开。

第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。**客户端经过2个最长报文段寿命后，客户端CLOSE**；服务器收到确认后，立刻进入CLOSE状态，客户端确认服务器断开。

### 为什么连接的时候是三次握手，关闭的时候却是四次挥手？

连接时，当服务端收到客户端的SYN连接请求报文后，**可以直接发送SYN+ACK报文**，对应用于同步+应答。

连接关闭时，当服务端收到FIN报文时，也许还有话要说，**并不会立即关闭SOCKET，所以不会立即返回一个FIN，而是先回复一个ACK报文**，告诉客户端自己已经收到了FIN，而只有等服务端把要说的话说完，才能发送FIN，因此需要四步。

### 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

我们需要假想**网络传输是不可靠的，有可能最后一个ACK将会丢失**，TIME_WAIT状态可以用来重发可能丢失的ACK报文。在客户端发出最后的ACK回复时，如果服务端没有收到ACK，它将不断重复发送FIN片段，所以客户端不能立即关闭，它必须确认服务端收到了该ACK。

客户端会在发出ACK之后进入TIME_WAIT的状态，并等待两倍的MSL的时间，Maximum Segment Lifetime，片段在网络中的最大生存时间，两倍的MSL就是一个发送和一个回复所需要的最大时间，如果超出该时间，客户端还没有再次收到FIN，那么客户端就会推断ACK已经被成功接收，此时TCP连接结束。

### 为什么不能用两次握手进行连接？

三次握手完成了两个重要的功能：

- 双方做好发送数据的**准备**工作。
- 允许双方就**初始序列号**进行协商，这个序列号在握手过程中被发送和确认。

**现在把三次握手改成仅需要两次握手，死锁是可能发生的**。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。**服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时**，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### CLOSE-WAIT  TIME-WAIT

> netstat -a

![image-20240724134432190](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240724134432190.png)

CLOSE-WAIT : 服务端被动接受断开连接请求。已经接收到FIN，但还没有发送自己的FIN的时候，处于close wait。

TIME-WAIT：发送完最后一次ACK报文段后，进入TIME-WAIT，等待2msl，防止最后ACK报文段丢失。

> netstat -an|grep TIMEWAIT|wc -l
>
> |: 管道是Unix和类Unix系统中的一个特性，它允许将一个命令的输出作为另一个命令的输入

### TIME-WAIT状态过多？

高并发短连接： 服务器主动申请关闭连接，造成time-wait过多。

解决办法：负载均衡服务器；web服务器首先关闭来自负载均衡服务器的连接

# （*）从输入网址到获取页面发生了什么？

- 根据输入的URL地址，查询DNS， 获取域名对应的IP地址
  - 浏览器搜索自身的DNS缓存
  - 发起系统调用查询本机hosts文件是否有配置ip地址
  - 发起一个DNS系统调用（宽带运营服务器查看本身缓存，运营服务器发起一个迭代DNS解析请求）
- 浏览器**获得域名对应的IP地址后，需要和目标服务器建立TCP连接，需要经过三次握手的过程**
- TCP/IP建立连接后，**创建http请求报文**，通过**SSL加密**，向服务器**发送HTTP请求**，之后可能会有【负载均衡+重定向】的过程。
- 服务器**接收到http请求**后，根据路径参数，经过后端处理将页面返回给浏览器
  - 如果是一个简单页面，将会直接返回。
  - 如果是需要重定向，返回的状态码为3开头的重定向码，浏览器在响应的报文中Location中找到重定向地址，继续第一步。
- **浏览器渲染页面**，和外部资源，最终将完整的页面呈现给用户
- 断开TCP连接：四次挥手。

# DNS是啥？

**DNS(Domain Name System) 域名系统**

提供能够将把主机名【如www.balabala.com】转化为IP地址【10.33.21.12】的转换服务。DNS 是一种由分层的 DNS 服务器实现的分布式数据库。DNS 运行在 UDP 上，使用 53 端口。

图片来源：https://mp.weixin.qq.com/s/t7ZYT6wBBbFYVBPOSztpRg

![640](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640.png)

一般域名服务器层次结构主要是上面三种：

- 根域名服务器
- 顶级域名服务器
- 权威DNS服务器

还有一种很重要的DNS服务器：**本地DNS服务器 local DNS server**，

> 严格来说，本地 DNS 服务器并不属于上述层次结构，但是本地 DNS 服务器又是至关重要的。每个 `ISP(Internet Service Provider)` 比如居民区的 ISP 或者一个机构的 ISP 都有一台本地 DNS 服务器。当主机和 ISP 进行连接时，该 ISP 会提供一台主机的 IP 地址，该主机会具有一台或多台其本地 DNS 服务器的 IP地址。通过访问网络连接，用户能够容易的确定 DNS 服务器的 IP地址。当主机发出 DNS 请求后，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次系统中。

查询请求会先找到本地 DNS 服务器来查询是否包含 IP 地址，如果本地 DNS 无法查询到目标 IP 地址，就会向根域名服务器发起一个 DNS 查询。在由【根域名服务器 -> 顶级域名服务器 -> 权威 DNS 服务器】后，由权威服务器告诉本地服务器目标 IP 地址，再有本地 DNS 服务器告诉用户需要访问的 IP 地址。

**DNS涉及两种查询方式**：

1. 递归查询：如果根域名服务器无法告知本地 DNS 服务器下一步需要访问哪个顶级域名服务器，就会使用递归查询。
2. 迭代查询：如果根域名服务器能够告知 DNS 服务器下一步需要访问的顶级域名服务器，就会使用迭代查询。

## 正向代理与反向代理

正向代理：隐藏真实的客户端。

1. 做缓存，加速访问资源。
2. 对客户端授权。
3. 客户端访问记录。

反向代理隐藏真实的服务端。

1. 实现负载均衡。
2. 避免网络攻击。

# IP报文格式

![image-20240724143548428](img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20240724143548428.png)



# 参考

- [https://mp.weixin.qq.com/s/t7ZYT6wBBbFYVBPOSztpRg](https://mp.weixin.qq.com/s/t7ZYT6wBBbFYVBPOSztpRg)
- [JavaGuide 计算机网络部分](https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C)