为什么要用消息队列啊？（优点）

使用的时候 有没有什么问题？（缺点）没有绝对的好坏！

和其他的mq比呢？为什么选择其中一个（哪些方面的考虑）

https://cloud.tencent.com/developer/article/2113802

## 项目场景

我们项目有一个场景：每次扣减完库存，都会写入到mq延迟消息，缓慢更新数据库的库存。redis内的预热库存消耗完毕后，发送最终mq消息，更新数据库剩余库存为0。这里用到了延迟消费的特性， 减缓流量峰值高的场景下，应对数据库更新库存压力大的挑战（因为我们不能 Redis 扣减的多快，就直接打到库表上，那样对数据库的压力依然很大，容易打挂）。（削峰）

还有一个场景是，用户中奖后，从用户中奖到发奖，使用mq做异步解耦，因为发奖品的方法不一定就在抽奖系统里，可能是其他通过其他的rpc或http接口来发放（接口可能会超时，会重试，这时候就是卡住）。我们通过异步解耦，中奖后，写一个用户中奖流水+task任务表发送mq记录，记下状态，再发送一个mq消息，等到奖品真正发完以后，更新这个状态。（异步、解耦）

## 有什么问题呢？

加入mq之后，系统更复杂

会有消息消费失败、重复消费等问题！

还会有一致性问题！

### 发送消息失败怎么办？（消息丢失问题、可靠性保证）

这里用mq解耦发奖操作，但是引出了一个问题，mq发送消息失败怎么办，这个奖就不发了？因此，就把发送mq消息这个任务写入数据库，定时任务去扫，消费完成之后，把数据库的状态更新一下。做一个补偿处理，一定能保证消息被消费掉

### 生产者如果多次发送同一个mq，保证奖品不会超发？（重复消费问题）

用**幂等的设计处理**，mq的消息必须含带具有唯一标识的业务id。比如订单id，奖品id，支付单id。接收mq的系统，通过唯一业务id，更新或者写库的时候查一下有没有消费过，消费过的话就不处理了，可以保证幂等，这样奖品就不会超发。

这里涉及到的知识有 全局id怎么保证唯一？

> 基于数据库的唯一键约束也可以

### 消费mq的过程中，使用多线程会产生什么问题

这是一个非常容易产生事故的问题，本身 MQ 消费就是多个应用分别消费，如果有消费失败的，可以抛异常重试。但如果是一个消费 MQ 的应用，里面写了多线程，就可能会出现大量的 MQ 挤压，消费不过来，导致系统瘫痪。而如果你重启，那么这些拉下来的 MQ 消息也就随时丢失了。

### 消息积压

消费端宕机？紧急扩容，先修复consumer的问题，多机部署consumer，快速消费

### 消息过期失效

这个没关系，我们有任务表兜底，只要没被消费，状态字段就一直不会更新。


## 为什么不用其他的？

依据项目的需求，时效性+延迟+稳定，选择rabbit

rabbitmq 延迟最低，时效性最强，基于主从实现高可用，消息基本不丢

rocketmq，java开发扩展性好，支持高吞吐10万级，分布式架构支持高可用，消息可靠参数配置正确0丢失

kafka 大数据领域、实时计算、日志收集等，支持高吞吐10万级，分布式高可用，消息可靠参数配置正确0丢失

