## 锁的类型

基于锁的属性分类：共享锁、排他锁

基于锁的粒度分类：行级锁InnoDB，表级锁MyIsam，页级锁，记录锁，间隙锁，临建锁。

基于锁的状态分类：意向共享锁，意向排他锁

## 共享锁Share lock

读锁，s锁：支持并发读。

一个事务为数据加上读锁后，其他事务只能对该数据加读锁，不能加写锁。

## 排他锁Exclusive lock

写锁，x锁

一个写锁会阻塞其他的读锁和写锁，只允许一个用户写入，防止其他用户读取正在写入的资源。

## 表锁

锁整个表，下一个事务访问该表时，需要等前一个事务释放锁才可以。

> 当索引失效时，行锁会升级为表锁。

特点：粒度大，易冲突。

## 行锁

锁某一行或多行。

特点：粒度小，不容易冲突，相比表锁支持的并发要高。

`select * from tab where id = 1 for update`

## 记录锁 record lock

是行锁的一种，记录锁锁住的范围只是表中的某一条记录。

加了记录锁后，可以避免重复读和脏读的问题。

## 页锁

锁粒度介于表锁和行锁之间，一次锁定相邻的一组记录。

特点：开销和加锁事件介于表锁和行锁之间；会出现死锁；并发度一般。

## 间隙锁 gap lock

属于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的**某一个区间**，当表的相邻id之间出现空隙则会形成一个区间，遵循左开右闭原则。

例如：数据有id = 1， 3，5，7四条数据，在查找1-7范围的数据，1-7都会被加上锁，2，4，6不在这些记录中，就是所谓的间隙。

间隙锁只会出现在RR的事务级别中，防止幻读问题。

## 临键锁 next-key-lock

属于行锁的一种，它是innodb的行锁默认算法：是**记录锁record lock和间隙锁gap lock的结合**，通过在index上加lock实现：

1. 如果index为唯一索引，降级为record lock。
2. 如果是普通索引，为next-key lock。
3. 如果没有index，则直接锁住全表，即表锁。

临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也锁住，且将相邻的下一个区间也锁住。意思是，加了next-key-lock后，返回区间内数据不允许被修改和插入。

临键锁的存在，使得Mysql在RR级别就可以解决脏读、重复读、幻读的问题。

## 悲观锁

在整个数据处理

