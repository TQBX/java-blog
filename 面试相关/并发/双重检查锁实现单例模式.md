用双重检查锁的方式实现单例模式：

```java
public class Singleton {
	//注意使用volatile防止指令重排序
    private volatile static Singleton instance;
	//私有化构造方法，单例模式基本操作
    private Singleton() {
    }
	//静态获取单例的方法
    public  static Singleton getInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (instance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

使用`volatile`的原因：防止指令重排序。

> `instance= new Singleton();`这一步，是一个实例化的过程，底层其实分为三部执行：
>
> 1. 为instance分配内存空间：`memory = allocate();`
> 2. 实例化instance。`ctorInstance(memory);`
> 3. 将instance指向分配的内存地址。`instance = memory;`

由于JVM具有指令重排序的特性，指令的执行顺序可能会变成1，3，2。在多线程环境下，可能某个线程可能会得到未初始化的实例。

举个例子：加入线程A执行了1和2之后，线程B调用getInstance的时候，会发现instance不为null，会直接返回这个没有执行过指令3的实例。

