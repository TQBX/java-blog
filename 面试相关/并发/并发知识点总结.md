## 按顺序打印ABC的思路

**Lock**

```java
public class T {

    static int state = 0;

    public static void main (String[] args) {

        Lock lock = new ReentrantLock();

        Thread A = new Thread(new Runnable() {
            @Override
            public void run () {
                while(state <= 30){
                    lock.lock();
                    if(state % 3 == 0){
                        System.out.println("A");
                        state ++;
                    }
                    lock.unlock();
                }
            }
        });
        Thread B = new Thread(new Runnable() {
            @Override
            public void run () {
                while(state <= 30){
                    lock.lock();
                    if(state % 3 == 1){
                        System.out.println("B");
                        state ++;
                    }
                    lock.unlock();
                }
            }
        });
        Thread C = new Thread(new Runnable() {
            @Override
            public void run () {
                while(state <= 30){
                    lock.lock();
                    if(state % 3 == 2){
                        System.out.println("C");
                        state ++;
                    }
                    lock.unlock();
                }
            }
        });

        A.start();
        B.start();
        C.start();
    }
}
```

**Lock + Condition**

```java
public class t2 {

    private static final Lock lock = new ReentrantLock();
    private static int state = 0;
    private static final Condition A = lock.newCondition();
    private static final Condition B = lock.newCondition();
    private static final Condition C = lock.newCondition();

    static class A extends Thread{
        @SneakyThrows
        @Override
        public void run () {
            lock.lock();
            for(int i = 0; i < 10; i ++){
                while(state % 3 != 0){
                    A.await();
                }
                System.out.println("A");
                state ++;
                B.signal();
            }
            lock.unlock();
        }
    }
    static class B extends Thread{
        @SneakyThrows
        @Override
        public void run () {
            lock.lock();
            for(int i = 0; i < 10; i ++){
                while(state % 3 != 1){
                    B.await();
                }
                System.out.println("B");
                state ++;
                C.signal();
            }
            lock.unlock();
        }
    }
    static class C extends Thread{
        @SneakyThrows
        @Override
        public void run () {
            lock.lock();
            for(int i = 0; i < 10; i ++){
                while(state % 3 != 2){
                    C.await();
                }
                System.out.println("C");
                state ++;
                A.signal();
            }
            lock.unlock();
        }
    }

    public static void main (String[] args) {
        new A().start();
        new B().start();
        new C().start();
    }
}
```

# 讲讲wait方法的底层原理

wait方法会将当前线程放入wait set等待被唤醒，等待被notify或notifyAll。

1. 将当前线程封装成objectwaiter对象node
2. 通过`objectmonitor::addwaiter`方法将node添加到_WaitSet列表中
3. 通过`ObjectMonitor:exit`方法释放当前的ObjectMonitor对象，这样其他竞争线程就可以获取该ObjectMonitor对象
4. 最终底层的park方法会挂起线程

而notify就是随机唤醒等待池中的一个线程。

