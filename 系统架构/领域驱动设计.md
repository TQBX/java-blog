# 技术文章参考

## 1. 领域驱动设计DDD在B端营销系统的实践

> 系统复杂性根源于隐晦（难理解）、耦合（难改动）和变化（难扩展），DDD正是应对系统复杂性的重要方法。

通过营销活动实现客户/用户拉新、留存和促活，实现商户增长和留存。

### 软件系统的复杂性：

1. 隐晦：抽象层面的隐晦，难以理解他人抽象系统的视角。代码层面的隐晦，和现实世界的业务概念脱节，理解成本++。
2. 耦合：代码、模块、系统，成本++。
3. 变化：业务需求决定了系统功能，需求不断变化，改动频次++范围++。

### 回顾历史

1. 早期创新聚焦于语言方面
2. 60年代，聚焦于语言的表达能力（面向对象：封装继承多态）
3. 80年代：建模、面向对象
4. <u>2000年：DDD，分析业务、抽取概念，建立对应的领域模型，再采用面向对象的分析与设计方法构建对应的类模型，达成了从物理世界到计算机世界的映射。</u>

### 什么是领域？

三部分：涉众域、问题域、解决方案域

- 涉众域：领域里有用户
- 问题域：用户要实现某种业务价值，解决某些痛点或实现某种诉求
- 解决方案域：面对业务价值、痛点、诉求，有对应的解决方案。

### 什么是领域驱动设计？

<u>针对特定业务，用户在面对业务问题时有对应的解决方案</u>，这些问题与方案构成了：**领域知识**，它包含流程、规则以及处理问题的方法。领域驱动设计就是围绕这些知识来设计系统。

- 用户：运营、销售、 电销人员、商户
- 解决3个核心问题：如何发券、发给谁、发什么
- 解决方案：通过营销活动来承载发券，不同活动类型对应不同玩法（买赠、折扣、充送）；通过目标人群来确定发给谁；通过权益来定义发什么（红包、代金券、折扣券）

### 怎么落地？

1. 战略设计：确定用例，统一语言和划分边界
2. 战术设计：概念模型转化为类模型
3. 代码架构：将系统设计映射为系统实现

#### 战略设计

> 确定用例（业务是怎么玩的），用例图、用户故事、交互原型、事件风暴
>
> 统一语言，从用例中抽取概念，并对概念进行甄别，找到真正描述业务的概念。
>
> 明确概念的含义，概念（术语，Term、含义三部分构成）
>
> 理清概念之间的关系（1对1、多对1、多对多）确定概念所代表的的业务实体的核心属性和行为，从而得到概念模型
>
> 基于统一语言和概念模型，业务 - 产品 - 技术三个角色比较容易就需求达成共识，保障沟通的一致性

本源论认为世界的本质是简单的，复杂问题由多个简单问题构成；康威原理认为系统架构受制于组织沟通架构，系统落地时，首先要确定系统边界，再依据系统边界组织分工。这两个原理表明：**我们可以将复杂问题拆解为多个简单问题，并针对团队资源组织分工协作。**

**如何拆解复杂问题？**

1. 基于涉众域拆解：不同的用户使用不同的系统功能。
2. 基于问题域：不同角色/用户 要解决的问题是相同的，基于问题域拆解。
3. 基于解决方案域：不同的问题可能有相同的解决方案（抽象）。

> 营销系统基于问题域拆解为 五个子域：活动、权益、人群、推送、数据，每个子域解决特定的问题，各个子领域相对内聚和简单：

![img](img/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/551e72b1caf337c48e2f902d543e19db296195.png)

业务系统要运转起来，需要子域之间相互配合，这就要定义上下文映射，实现不同子域间的协作。

#### 战术设计

战略设计得到了概念模型，战术设计则是将概念模型映射为代码模型，有很多编程范式，比如事务脚本、表模式、面向对象，函数式等，最好的方式是面向对象的实现。

从概念模型到对象模型：1. 通过派生/继承实现概念分层，2. 通过组合实现包含关系 3. 概念的属性行为可以直接变成对象的属性和行为。

**实体对象和值对象**

两类对象：实体和值对象，这两者的区别是是否有统一标识和自己的状态，实体：具有状态、唯一标识，值对象：无生命周期、无唯一标识。

有了对象模型，还需要通过**聚合根**完成封装，如何确定聚合根的粒度？

聚合根的设计要遵循一定的原则：

1. 满足业务一致性、数据完整性、状态一致性。比如库存档位和活动状态要一致，在数据上也要完整，不存在没有档位的活动，也不存在没有库存的活动。
2. 技术限制。有些实体会带来技术挑战，如数据量太大，可抽出来单独考虑。
3. 业务逻辑不灭，在业务封装与适度的职责边界之间寻找平衡。不管是大聚合根还是小聚合根，业务逻辑永远都是存在的，就是看把它放在哪里。

![img](img/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/3ea38ba415e116479834ce359ebcda89254849.png)

**在落地代码时，代码要体现出业务含义**，要避免updateStatus()这样的方法，它没有体现业务含义（必须阅读代码实现，才知道这个方法做了什么）；submitCampaign()，approveCampaign()，cancelCampaign()则有明确的业务含义。

#### 代码架构

几种架构：六边形架构、整洁架构、洋葱架构

核心：围绕领域模型展开，应用层、基础设施层和外部接口都依赖领域模型。

美团工程实践：

![img](img/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/71bd2865f6232f9faa13b4385ce634a4167129.png)

### 总结

1. 充分借鉴CRM、HR或SCM这些实践，没必要自己创造新概念
2. 要重视**统一语言**。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。
3. 领域驱动设计是团队工作，没有严格意义上的领域专家，参与到这项工作的人都可以是领域专家，一定要落地到产品和业务。
4. 拥抱变化，持续迭代。

领域驱动的精髓在于从业务出发，抽象出业务领域知识，构建概念模型，一步一步将这些概念模型映射成系统。至于如何采用聚合根、领域服务、实体、值对象、领域事件等，可以灵活取舍。

领域模型不是设计出来的，而是通过战略设计的几个步骤，从业务中抽象出来的，最重要是理解业务，对业务进行抽象。

使用了DDD就一定会产生好的领域模型的想法也不可取，我们知道飞机怎么造，但我们不一定能够造出好飞机，但如果我们知道这个方法，可以少走弯路。 

在聊需求的那一刻，设计就开始了，统一语言就是设计的一部分。

![img](img/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/fa1eae3c05f4d5fb2cfa122ce9f80546345768.png)

避免陷入CRUD boy和事务脚本陷阱！

## 2. [DDD在大众点评交易系统演进中的应用](https://tech.meituan.com/2024/05/09/ddd-practice-trading-system.html)

### 什么是领域驱动设计？

一种软件设计方法，处理复杂业务需求。

分解为：领域、驱动、设计三部分：

1. 领域：特定业务范围或问题域，确定领域之后，就能明确核心的业务问题。
2. 设计：领域模型的设计，DDD强调领域模型是系统的核心，它反映了业务概念和业务规则。
3. 驱动：两层含义，一是业务问题域驱动领域建模的过程，二是领域模型驱动技术实现或代码开发的过程

总结：**确保领域模型的准确性**是关键，因为它可以保证代码实现能够真实反映并解决业务的核心问题

领域驱动设计是一种设计思想，首先体现了分离的思想，它分离了业务复杂性和技术复杂性，其次体现了分治的思想，它通过领域模型、限界上下文或子域进行分治。

### 领域驱动设计的核心概念

统一语言：贯穿领域驱动设计从战略设计到战术设计到最后的代码实现全过程，包括需求分析、知识提炼和最后代码的实现。

限界上下文：连接**问题**空间和**解决方案**空间的桥梁，一方面我们在问题空间分析问题时，它是语言的边界和模型的边界；另一方面，在解决方案空间我们通过限界上下文来确定应用的边界和技术的边界，从而帮助我们确定整个系统及各个限界上下文的解决方案。

### 领域驱动设计的过程

1. 业务、产品、研发以及QA共同参与，基于对问题域以及业务愿景的理解，充分讨论，提炼领域知识，并建立统一语言。
2. 在领域知识基础上进一步提炼，分解问题域为核心子域、支撑子域和通用子域。
3. 通过模型驱动设计思想，设计领域模型，通过领域模型连接业务和系统，在设计过程中，会有新的认知迭代。

> 领域知识是一个不断迭代、螺旋式推进的过程

![img](img/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/73ef5bdb139188f23538eee06c960c99663524.png)

### 大众点评交易系统演进

从技术视角看，包括简单架构、微服务架构和平台化架构等三个阶段演进。

#### 简单架构

规模小，只支持了预订形态的一两个品类的交易，根据业务进行了基础的拆分。接入层分为商家B端、商品C端和订单C端，而服务层则划分为商家、商品和订单三个部分。整体上采用了传统的MVC分层架构。这种架构在项目初期确实展现出了其优势，即“简单”和“快”。

弊端

1. 数据驱动设计，通常先建立数据库表，无法反映业务实际情况。
2. 传统分层架构，数据库表映射为PO，在服务层CRUD过程式编程，在多个场景下出现功能相似但不同的需求，导致重复编写相似的代码，内聚性不足。

在传统的MVC架构模式下，由于缺乏对业务领域的深入理解和沉淀，服务间的调用往往缺乏清晰的结构，导致逻辑交织在一起。此外，研发团队在系统迭代过程中可能没有足够重视高内聚和低耦合的设计原则。因此，系统内部往往会出现多处重复且相似的订单退款代码逻辑，这不仅降低了系统的可读性，也给系统的可维护性带来了挑战。 

#### 微服务化阶段

挑战：

1. 业务规模的扩张带来了系统规模和代码量的增加
2. 业务需求的累积导致了系统内部的重复代码、复杂的依赖关系，以及为了满足高可用性和高性能需求而引入的各种技术组件和并行、异步解决方案
3. 业务需求的频繁变动也增加了系统的复杂性

解决方案：

通过**分治**的方法来管理软件规模，利用系统分层和关注点分离的原则来优化系统结构，以及通过隔离变化来应对频繁的需求迭代。这些策略都是**领域驱动设计（DDD）的核心理念**，基于此，我们实施了微服务架构的拆分，以更好地管理和控制系统复杂性

将DDD的实施过程分为四个阶段：

1. 理解问题域：分析业务价值、需求、构建业务概念模型。统一语言和子域划分达成共识
2. 识别限界上下文：通过业务和应用的边界确定限界上下文，明确不同上下文之间的关系和交互
3. 领域建模：领域分析、设计建模、模型的持续迭代。目标是：构建能够反映业务核心概念的模型
4. 模型实现：依赖于应用分层架构、微服务架构和应用集成，确保领域模型能够有效实施

**世界限界上下文里面**：

> 限界上下文的划分，和子域划分的结果基本是一致的

限界上下文封装了按照纵向切分的业务能力，**那多个限界上下文如何协作来完成一个完整的业务场景**呢，这就涉及到限界上下文的映射，按照通信集成模式和团队协作模式来划分，有多种映射关系，这里面我们用到最多的是通过防腐层、开放主机服务和发布语言三者联动来隔离上下游的变化、维护整个领域模型的稳定性。

**领域建模里面**：基于DDD战术设计的元模型，识别出这些概念中的实体和值对象，并且根据业务规则的不变性设计聚合。

![img](img/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/05a64b8a361d948a57e33c88e2f81242520792.png)

**模型实现里面**：按照限界上下文划分微服务，服务内部按照分层架构进行实现。整体上基于关注点分离和SOLID原则，分为接入层、应用层、领域层和基础设施层。最终需要维护领域层的稳定性，对上由接入层和应用层来隔离变化，对下由基础设施层通过依赖倒置的方式来隔离数据以及外部依赖的差异性和变化

![img](img/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/3a83bdbedf526a06225285476ca640d0501469.png)

#### 平台化阶段

随着业务的不断发展，出现了商场团购、内容商业化等更多的交易业务场景，在技术上可以通过平台化的思路将底层系统能力进行复用来提升各业务的支持效率。

同时，DDD的战略模式也在重点关注组织上如何更好的管理大型业务系统，因此我们可以**结合DDD来构建平台领域模型和业务扩展模型**，从而更加高效地完成平台化改造

为了实现在多业务之间进行最大化复用的目标，我们在平台领域模型的构建上做了进一步的提炼，将平台领域模型拆解为基础领域模型，以及预订业务模型、团购业务模型等按照业务形态划分的领域模型

为了提升业务BP和平台团队的协作效率，在平台领域模型和业务领域模型划分的基础上，我们采用了基于插件化的集成开发模式。通过扩展点的定义，由各业务线在各自的插件包里基于业务扩展模型进行业务定制化实现，再集成平台领域模型和业务扩展模型，最后实现完整的业务流程和业务场景

# DDD理念

概念：充血模型、领域模型、实体、聚合、值对象、仓储和适配器、领域编排、触发器

## 充血模型

将对象的属性信息与行为逻辑聚合到一个类中，常用的手段如在对象内提供属于当前对象的`信息校验`、`拼装缓存Key`、`不含服务接口调用的逻辑处理`等

- 对象层面的充血：对象属性、行为聚合到一个类中。
- 服务层面的充血：领域服务包下：service，dao，领域对象，一个包下包括了用于实现此包 Service 服务所需的各类零部件（模型、仓储、工厂），也可以被看做充血模型。

优点：使用对象时，可以顺便用对象提供的方法。

贫血模型和充血模型？

- 贫血模型：基础设施（对象、方法、接口）相互调用
- 充血模型：以一个领域功能为聚合，拆分一个领域内所需的service为领域服务，vo，req，res重新设计为领域对象，dao，redis设置为仓储。

## 领域模型

特定业务领域内，业务规则、策略以及业务流程的抽象和封装。在设计手段上，通过风暴模型拆分领域模块，形成界限上下文。最大的区别在于把原有的`众多 Service + 数据模型`的方式，拆分为独立的有边界的领域模块。每个领域内创建自身所属的；领域对象（实体、聚合、值对象）、仓储服务(DAO 操作)、工厂、端口适配器Port（调用外部接口的手段）等。

自身只关注业务功能实现，不与外部任何接口和服务直连。不会直接调用 DAO 操作库，也不会调用缓存操作 Redis，更不会直接引入 RPC 连接其他微服务。而是通过仓库和端口适配器，定义调用外部数据的含有出入参对象的接口标准，让基础设施层做具体的调用实现。通过这样的方式让领域只关心业务实现，同时做好防腐。

> 防腐是一个重要概念，防腐层的主要目的是保护领域模型的完整性和业务逻辑免受外部技术基础设施的污染或影响。在实践中，防腐层通常通过定义一系列的**接口或抽象类**来实现，这些接口或抽象类由领域模型层定义，但由基础设施层或应用层实现。

## 实体、值对象、聚合

贫血模型开发模式，不会特别在意一个方法的出入参对象，只关注能否传递对象的属性信息。

实体、聚合、值对象，三者位于每个领域下的领域对象内，服务于领域内的领域服务。三个对象定义具体如下：

- 实体：**唯一标识** + 状态属性 + 行为动作（功能）。实体不仅仅包含数据（状态属性），还包含了相关的行为（功能），并且它的标识在整个生命周期中保持不变。
- 聚合：对数据库的操作需要使用到多个实体时，可以创建聚合对象。**一个聚合对象，代表着一个数据库事务，具有事务一致性**。聚合中的实体可以由聚合提供创建操作，实体也被称为聚合根对象。
- 值对象：值对象是由**一组属性组成的**，它们共同描述了一个领域概念。值对象通常是不可变的，这意味着一旦创建，它们的状态就不应该改变。

## 仓储和适配器

在 DDD 的设计方法中，领域层做到了只关心领域服务实现。最能体现这样设计的就是仓库和适配器的设计。Repository模式是DDD（领域驱动设计）中的一个核心概念，它有助于保持领域模型的聚焦和清晰，同时提供了灵活、可测试和可维护的数据访问策略。

基础设施层实现领域层接口（仓储/适配器），基础设置层负责原则对接`数据库`、`缓存`、`配置中心`、`RPC接口`、`HTTP接口`、`MQ推送`等各项资源，并承接领域服务的接口调用各项服务为领域层提供数据能力。

## 领域编排

在 DDD 中，每一个领域都是界限上下文拆分的独立结果，而实现业务流程的功能则需要串联各个领域模块提供一整条链路的完整服务。所以也常说领域内事务一致性，领域外最终一致性。

同时这些领域模块因为是独立的，所以也可以被复用。在不同的场景功能诉求下，可以选择不同的领域模块进行组装，这个过程就像搭积木一样。

但这里有一个取舍，如果项目相对来说并不大，也没有太多的编排处理。那么可以直接让触发器层对接领域层，减少编排层后，编码会更加便捷。

## 触发器

在所有的模型都定义完成后，领域业务被串联了。那么接下来则是使用，而使用的方式可以包括；接口（http/rpc）、消息监听、定时任务等方式，这些方式统一被定义为触发动作。

由触发发起对编排功能的调用处理。如；定时任务做信贷的计息、开户成功消息通知返利优惠券、提供接口让外部调用授信逻辑等。这些都是触发动作。

# DDD与MVC

![img](img/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/road-map-230624-01.png)

MVC在大型且长期维护的项目中，dao，po，vo对象在service相互调用，导致各个po的属性字段数量撑大，将`”状态”`、`“行为“`分离到不同的对象中，代码的意图渐渐模糊，膨胀、臃肿和不稳定的架构，让迭代成本增加。

![img](img/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/road-map-ddd-02.png)

DDD 架构将各个**属于自己领域范围内的行为和逻辑封装到自己的领域包下处理**。这也是 DDD 架构设计的精髓之一。它希望在分治层面合理切割问题空间为更小规模的若干子问题，而问题越小就容易被理解和处理，做到高内聚低耦合。这也是康威定律所提到的，解决复杂场景的设计主要分为：**分治、抽象和知识**。

![img](img/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/roadmap-ddd-01.png)
