## 交叉连接

SQL99的cross join

```sql
SELECT
	* 
FROM
	player
	CROSS JOIN team
```

多表交叉连接

```sql
SELECT
	* 
FROM
	t1
	CROSS JOIN t2
	CROSS JOIN t3
```

## 自然连接

```sql
SELECT
	player_id,
	team_id,
	player_name,
	height,
	team_name 
FROM
	player
	NATURAL JOIN team
```

## on连接

ON 连接用来指定我们想要的连接条件。

- 用on进行team_id的等值连接。

```sql
SELECT
	player_id,
	player.team_id,
	player_name,
	height,
	team_name 
FROM
	player
	JOIN team ON player.team_id = team.team_id
```

- 用on进行非等值连接

```sql
SELECT
	p.player_name,
	p.height,
	h.height_level 
FROM
	player AS p
	JOIN height_grades AS h ON height BETWEEN h.height_lowest 
	AND h.height_highest
```

一般来说在 SQL99 中，我们需要连接的表会采用 JOIN 进行连接，ON 指定了连接条件，后面可以是等值连接，也可以采用非等值连接。

## USING连接

```sql
SELECT
	player_id,
	team_id,
	player_name,
	height,
	team_name 
FROM
	player
	JOIN team USING ( team_id )
```

与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 JOIN USING 可以简化 JOIN ON 的等值连接，它与下面的 SQL 查询结果是相同的：

```sql
SELECT
	player_id,
	player.team_id,
	player_name,
	height,
	team_name 
FROM
	player
	JOIN team ON player.team_id = team.team_id
```

## 外连接

- 左外连接：LEFT JOIN 或 LEFT OUTER JOIN
- 右外连接：RIGHT JOIN 或 RIGHT OUTER JOIN
- 全外连接：FULL JOIN 或 FULL OUTER JOIN

```sql

SELECT * FROM player LEFT JOIN team ON player.team_id = team.team_id

SELECT * FROM player RIGHT JOIN team ON player.team_id = team.team_id

```

mysql不支持全外连接，**全外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据**。

```sql
SELECT * FROM player FULL JOIN team ON player.team_id = team.team_id
```

## 自连接

```sql
SELECT
	b.player_name,
	b.height 
FROM
	player AS a
	JOIN player AS b ON a.player_name = '布雷克-格里芬' 
	AND a.height < b.height
```

## SQL99

```sql

SELECT ...
FROM table1
    JOIN table2 ON table1和table2的连接条件
        JOIN table3 ON table2和table3的连接条件
```

## 不同DBMS中连接需要注意的

1. 不是所有的DBMS都支持全外连接，比如mysql。
2. Oracle没有表别名AS。
3. SQLite的外连接只有左连接。

## 性能问题

1. 控制连接表的数量。
2. 在连接时不要忘记where语句，过滤掉不必要的数据行。
3. 使用自连接而不是子查询。**子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断**，因此在大部分 DBMS 中都对自连接处理进行了优化。

