> https://time.geekbang.org/column/article/69236

索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。

## 索引的常见类型

索引：提高查询效率。

具体实现索引的方式有多种，基于多种索引模型实现，其实就是数据结构：哈希表、有序数组、搜索树。

1. 哈希表：无序的，区间查询速度慢，只适用于等值查询的场景。

2. 有序数组：等值查询和范围查询的场景中性能都非常优秀，有序数组可以使用二分将时间复杂度优化到logN，但针对插入和删除场景，需要挪动后面的整个记录，代价太高。因此，有序数组只适用于静态存储引擎【不会再修改的数据】。

3. 搜索数：
   1. 二叉搜索数：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。中序遍历是有序的。为了保证logN的查询复杂度，应当尽量保证其为平衡二叉树。二叉树树高过高，每次查询都需要访问过多节点，即访问数据块过多，而从磁盘随机读取数据块过于耗时。
   2. 多叉数，每个节点有多个儿子，儿子保证从左到右递增。N叉数的N取决于数据块的大小，保证查询尽量少地读磁盘，也就是访问尽量少的数据块。

> MySql默认一个节点的长度为16K，一个整数（bigint）字段索引的长度为 8B,另外每个索引还跟着6B的指向其子树的指针；所以16K/14B ≈ 1170
>
> 以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

<u>数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</u>

在mysql中，索引是在存储引擎层实现的，所以并没有统一的索引标准，不同存储引擎的索引的工作方式并不一样。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。本篇主要分析InnoDB的索引模型。

## InnoDB的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。

> **B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数**。

每一个索引在 InnoDB 里面对应一棵 B+ 树。

> 聚簇索引以INNODB为例，叶子结点即存储了真实的数据行，不再有另外单独的数据页。
>
> 非聚簇索引以MYISAM为例，是按列值与行号来组织索引的，它的叶子节点中保存的实际上是指向存放数据的物理块的指针，索引文件（.MYI）和数据文件(.MYD)

**主键索引和非主键索引**

```sql
mysql> create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB;
```

![img](img/04索引上/dcda101051f28502bd5c4402b292e38d.png)

- 主键索引的叶子节点存的是**整行数据**。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。

- 非主键索引的叶子节点内容是**主键的值**。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。

**查询上面有什么区别？**

- 主键索引，`select * from T where ID = 500`，只需要搜索ID这棵B + 树。

- 非主键索引，`select * from T where k = 5`，需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次，称为**回表**。【不一定会触发回表，如果查询的字段在二级索引中，那么就不会触发回表的操作】

因此，基于非主键索引的查询需要多扫描一颗索引树，尽量使用主键查询。

## 索引的维护

B + 树为了维护索引有序性，在插入新值的时候需要做必要维护。以上图为例，如果插入700，直接在R5记录后面插入一个新纪录即可，如果新插入的是400，则需要逻辑上挪动后面的数据，空出位置。

甚至，如果R5所在的数据页已满，这时需要申请一个新的数据页，然后挪动部分数据过去，称为页分裂。当然，有分裂也会有合并，当相邻两个页删除了数据，会做数据页合并。

> 页分裂影响性能 与数据页的利用率。

## 自增主键

自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： `NOT NULL PRIMARY KEY AUTO_INCREMENT`。

**性能角度**

自增主键的插入数据模式，正符合**递增插入**的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

**存储空间角度**

由于**每个非主键索引的叶子节点上都是主键的值**。如果用业务字段做主键，占用大小不好控制，比如身份证：每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。

**哪些场景适合用业务字段做主键呢？**

1. 只有一个索引。
2. 该索引必须是唯一索引。

典型的kv场景：由于没有其他的索引，就不需要考虑其他索引的叶子节点大小的问题。

## 评论区补充

1. 每一张表是好几棵B+树，数节点的key值是某一行的主键，value是该行的其他数据。新建索引就是新增一个B+树，查询不走索引就是遍历主B + 树。
2. innodb使用的是聚集索引，即主键索引和行记录数据存在一起；
   - 当表每有主键的时候，会选择非空唯一的唯一键做为主键索引。
   - 唯一索引页不存在的时候会分配8字节无符号的rowId作为主键索引，rowId达到最大后会重新归为0即覆盖之前的数据。