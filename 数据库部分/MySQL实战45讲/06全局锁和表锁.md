锁：处理并发问题，控制资源的访问规则。

根据加锁的范围，mysql中的锁分为：全局锁，表级锁，行锁。

## 全局锁

全局锁就是对整个数据库实例加锁。mysql中全局加读锁的方法：`Flush tables with read lock(FTWRL)`。

当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：

1. 数据更新语句，数据的增删改。
2. 数据定义语句，建表，修改表结构。
3. 更新类事务的提交语句。

全局锁的典型使用场景：做全库逻辑备份，将整库每个表都select出来存成文本。

**备份过程中让整个库完全处于只读状态，会出现什么问题？**

1. 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
2. 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。

如何处理？使用官方自带的逻辑备份工具：mysqldump，前提是需要支持事务的引擎支持，因此，如果不支持，那就只能使用FTWRL了。

> 当 mysqldump 使用参数–single-transaction 的时候，**导数据之前就会启动一个事务，来确保拿到一致性视图**。而由于 **MVCC** 的支持，这个过程中数据是可以正常更新的。

## readonly与FTWRL的区别

readonly 方式也可以让全库进入只读状态，但依然建议使用FTWRL，原因如下：

1. 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议使用。
2. 两者在异常处理机制上存在差异，如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

## 表级锁

mysql中有两种表级锁：表锁和元数据锁（meta data lock MDL）。

### 表锁

表锁的语法： `lock tables ... read/ write`，与FTWRL类似，可以使用`unlock tables`主动释放锁，也可以在客户端断开时自动释放，需要注意，**lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象**。

> 对表加读锁后，自己也不能对其进行修改；自己和其他线程只能读取该表。 当对某个表执加上写锁后（lock table t2 write），该线程可以对这个表进行读写，其他线程对该表的读和写都受到阻塞；

如果没有更细粒度的锁【如行锁】时，表锁是最常用的处理并发的方式，而InnoDB支持行锁，一般不用表锁。

### 元数据锁MDL

MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，**保证读写的正确性**。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

1. **读锁之间不互斥**，可以有**多个线程同时对一张表增删改查**。
2. **读写锁之间、写锁之间是互斥的**，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。有未提交的事务时无法修改表字段，而且在存在长事务时执行修改表字段命令是一个危险的操作，可能阻塞其它增删改查请求，或导致线程爆满

## 如何安全地给小表加字段

1. 解决长事务，事务不提交，就会一直占着MDL锁。mysql的information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务。如果要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。

2. 如果变更的表是一个热点表，请求频繁，kill未必管用：在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。

