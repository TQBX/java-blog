mysql的行索是在引擎实现的。但并不是所有引擎都支持行锁。不支持行锁的引擎只能使用表锁，比如MyISAM 引擎就不支持行锁。

对于表锁来说，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

什么是**行锁**？ 针对数据表中的行记录的锁，比如事务更新了一行，事务B更新同一行，必须等事务A的操作完成后才能更新。

## 两阶段协议

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

知道了这个设定之后：如果你的事务中需要锁多个行，要**把最可能造成锁冲突、最可能影响并发度的锁尽量往后放**。

## 死锁和思索检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为**死锁**。

![img](img/07行锁/4d0eeec7b136371b79248a0aed005a52.jpg)

如何解决？

1. 直接进入等待，直到超时。超时参数：innodb_lock_wait_timeout，InnoDB中默认是50s。
2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

建议使用第二种方法：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。

但**热点行更新**怎么办呢？每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。

1. 如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。
2. 另一种思路是控制并发度，而且需要在数据库服务端做并发控制。或者通过将一行改成逻辑上的多行来减少锁冲突。

